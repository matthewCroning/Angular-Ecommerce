{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Matth\\\\workspace\\\\angular-ecommerce\\\\client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst HTTPRequest_js_1 = require(\"./HTTPRequest.js\");\n\nconst HTTPResponse_js_1 = require(\"./HTTPResponse.js\");\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n\n\nexports.NetworkManagerEmittedEvents = {\n  Request: Symbol('NetworkManager.Request'),\n  RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n  Response: Symbol('NetworkManager.Response'),\n  RequestFailed: Symbol('NetworkManager.RequestFailed'),\n  RequestFinished: Symbol('NetworkManager.RequestFinished')\n};\n/**\n * @internal\n */\n\nclass NetworkManager extends EventEmitter_js_1.EventEmitter {\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    /*\n     * There are four possible orders of events:\n     *  A. `_onRequestWillBeSent`\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`\n     *  C. `_onRequestPaused`, `_onRequestWillBeSent`\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`\n     *     (see crbug.com/1196004)\n     *\n     * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n     * optionally the `interceptionId` from `_onRequestPaused`.\n     *\n     * If request interception is disabled, call `_onRequest` once per call to\n     * `_onRequestWillBeSent`.\n     * If request interception is enabled, call `_onRequest` once per call to\n     * `_onRequestPaused` (once per `interceptionId`).\n     *\n     * Events are stored to allow for subsequent events to call `_onRequest`.\n     *\n     * Note that (chains of) redirect requests have the same `requestId` (!) as\n     * the original request. We have to anticipate series of events like these:\n     *  A. `_onRequestWillBeSent`,\n     *     `_onRequestWillBeSent`, ...\n     *  B. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestWillBeSent`, `_onRequestPaused`, ...\n     *  C. `_onRequestWillBeSent`, `_onRequestPaused`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, ...\n     *  D. `_onRequestPaused`, `_onRequestWillBeSent`,\n     *     `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`, ...\n     *     (see crbug.com/1196004)\n     */\n\n    this._requestIdToRequestWillBeSentEvent = new Map();\n    this._requestIdToRequestPausedEvent = new Map();\n    this._requestIdToRequest = new Map();\n    this._extraHTTPHeaders = {};\n    this._credentials = null;\n    this._attemptedAuthentications = new Set();\n    this._userRequestInterceptionEnabled = false;\n    this._protocolRequestInterceptionEnabled = false;\n    this._userCacheDisabled = false;\n    this._emulatedNetworkConditions = {\n      offline: false,\n      upload: -1,\n      download: -1,\n      latency: 0\n    };\n    this._client = client;\n    this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n    this._frameManager = frameManager;\n\n    this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n\n    this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n\n    this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n\n    this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n\n    this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n\n    this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n\n    this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n  }\n\n  initialize() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this._client.send('Network.enable');\n      if (_this._ignoreHTTPSErrors) yield _this._client.send('Security.setIgnoreCertificateErrors', {\n        ignore: true\n      });\n    })();\n  }\n\n  authenticate(credentials) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2._credentials = credentials;\n      yield _this2._updateProtocolRequestInterception();\n    })();\n  }\n\n  setExtraHTTPHeaders(extraHTTPHeaders) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      _this3._extraHTTPHeaders = {};\n\n      for (const key of Object.keys(extraHTTPHeaders)) {\n        const value = extraHTTPHeaders[key];\n        assert_js_1.assert(helper_js_1.helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n        _this3._extraHTTPHeaders[key.toLowerCase()] = value;\n      }\n\n      yield _this3._client.send('Network.setExtraHTTPHeaders', {\n        headers: _this3._extraHTTPHeaders\n      });\n    })();\n  }\n\n  extraHTTPHeaders() {\n    return Object.assign({}, this._extraHTTPHeaders);\n  }\n\n  setOfflineMode(value) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      _this4._emulatedNetworkConditions.offline = value;\n      yield _this4._updateNetworkConditions();\n    })();\n  }\n\n  emulateNetworkConditions(networkConditions) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      _this5._emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;\n      _this5._emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;\n      _this5._emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;\n      yield _this5._updateNetworkConditions();\n    })();\n  }\n\n  _updateNetworkConditions() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this6._client.send('Network.emulateNetworkConditions', {\n        offline: _this6._emulatedNetworkConditions.offline,\n        latency: _this6._emulatedNetworkConditions.latency,\n        uploadThroughput: _this6._emulatedNetworkConditions.upload,\n        downloadThroughput: _this6._emulatedNetworkConditions.download\n      });\n    })();\n  }\n\n  setUserAgent(userAgent, userAgentMetadata) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this7._client.send('Network.setUserAgentOverride', {\n        userAgent: userAgent,\n        userAgentMetadata: userAgentMetadata\n      });\n    })();\n  }\n\n  setCacheEnabled(enabled) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      _this8._userCacheDisabled = !enabled;\n      yield _this8._updateProtocolCacheDisabled();\n    })();\n  }\n\n  setRequestInterception(value) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      _this9._userRequestInterceptionEnabled = value;\n      yield _this9._updateProtocolRequestInterception();\n    })();\n  }\n\n  _updateProtocolRequestInterception() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      const enabled = _this10._userRequestInterceptionEnabled || !!_this10._credentials;\n      if (enabled === _this10._protocolRequestInterceptionEnabled) return;\n      _this10._protocolRequestInterceptionEnabled = enabled;\n\n      if (enabled) {\n        yield Promise.all([_this10._updateProtocolCacheDisabled(), _this10._client.send('Fetch.enable', {\n          handleAuthRequests: true,\n          patterns: [{\n            urlPattern: '*'\n          }]\n        })]);\n      } else {\n        yield Promise.all([_this10._updateProtocolCacheDisabled(), _this10._client.send('Fetch.disable')]);\n      }\n    })();\n  }\n\n  _cacheDisabled() {\n    return this._userCacheDisabled;\n  }\n\n  _updateProtocolCacheDisabled() {\n    var _this11 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this11._client.send('Network.setCacheDisabled', {\n        cacheDisabled: _this11._cacheDisabled()\n      });\n    })();\n  }\n\n  _onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (this._userRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {\n      const requestId = event.requestId;\n\n      const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);\n\n      this._requestIdToRequestWillBeSentEvent.set(requestId, event);\n\n      if (requestPausedEvent) {\n        const interceptionId = requestPausedEvent.requestId;\n\n        this._onRequest(event, interceptionId);\n\n        this._requestIdToRequestPausedEvent.delete(requestId);\n      }\n\n      return;\n    }\n\n    this._onRequest(event, null);\n  }\n\n  _onAuthRequired(event) {\n    let response = 'Default';\n\n    if (this._attemptedAuthentications.has(event.requestId)) {\n      response = 'CancelAuth';\n    } else if (this._credentials) {\n      response = 'ProvideCredentials';\n\n      this._attemptedAuthentications.add(event.requestId);\n    }\n\n    const {\n      username,\n      password\n    } = this._credentials || {\n      username: undefined,\n      password: undefined\n    };\n\n    this._client.send('Fetch.continueWithAuth', {\n      requestId: event.requestId,\n      authChallengeResponse: {\n        response,\n        username,\n        password\n      }\n    }).catch(helper_js_1.debugError);\n  }\n\n  _onRequestPaused(event) {\n    if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {\n      this._client.send('Fetch.continueRequest', {\n        requestId: event.requestId\n      }).catch(helper_js_1.debugError);\n    }\n\n    const requestId = event.networkId;\n    const interceptionId = event.requestId;\n\n    if (!requestId) {\n      return;\n    }\n\n    let requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId); // redirect requests have the same `requestId`,\n\n\n    if (requestWillBeSentEvent && (requestWillBeSentEvent.request.url !== event.request.url || requestWillBeSentEvent.request.method !== event.request.method)) {\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n\n      requestWillBeSentEvent = null;\n    }\n\n    if (requestWillBeSentEvent) {\n      this._onRequest(requestWillBeSentEvent, interceptionId);\n\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n    } else {\n      this._requestIdToRequestPausedEvent.set(requestId, event);\n    }\n  }\n\n  _onRequest(event, interceptionId) {\n    let redirectChain = [];\n\n    if (event.redirectResponse) {\n      const request = this._requestIdToRequest.get(event.requestId); // If we connect late to the target, we could have missed the\n      // requestWillBeSent event.\n\n\n      if (request) {\n        this._handleRequestRedirect(request, event.redirectResponse);\n\n        redirectChain = request._redirectChain;\n      }\n    }\n\n    const frame = event.frameId ? this._frameManager.frame(event.frameId) : null;\n    const request = new HTTPRequest_js_1.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n\n    this._requestIdToRequest.set(event.requestId, request);\n\n    this.emit(exports.NetworkManagerEmittedEvents.Request, request);\n    request.finalizeInterceptions().catch(error => {\n      // This should never happen, but catch just in case.\n      helper_js_1.debugError(error);\n    });\n  }\n\n  _onRequestServedFromCache(event) {\n    const request = this._requestIdToRequest.get(event.requestId);\n\n    if (request) request._fromMemoryCache = true;\n    this.emit(exports.NetworkManagerEmittedEvents.RequestServedFromCache, request);\n  }\n\n  _handleRequestRedirect(request, responsePayload) {\n    const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, responsePayload);\n    request._response = response;\n\n    request._redirectChain.push(request);\n\n    response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n\n    this._forgetRequest(request, false);\n\n    this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onResponseReceived(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // FileUpload sends a response without a matching request.\n\n\n    if (!request) return;\n    const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, event.response);\n    request._response = response;\n    this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n  }\n\n  _forgetRequest(request, events) {\n    const requestId = request._requestId;\n    const interceptionId = request._interceptionId;\n\n    this._requestIdToRequest.delete(requestId);\n\n    this._attemptedAuthentications.delete(interceptionId);\n\n    if (events) {\n      this._requestIdToRequestWillBeSentEvent.delete(requestId);\n\n      this._requestIdToRequestPausedEvent.delete(requestId);\n    }\n  }\n\n  _onLoadingFinished(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return; // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n\n    if (request.response()) request.response()._resolveBody(null);\n\n    this._forgetRequest(request, true);\n\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n  }\n\n  _onLoadingFailed(event) {\n    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n\n\n    if (!request) return;\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) response._resolveBody(null);\n\n    this._forgetRequest(request, true);\n\n    this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);\n  }\n\n}\n\nexports.NetworkManager = NetworkManager;","map":{"version":3,"sources":["C:/Users/Matth/workspace/node_modules/puppeteer/lib/cjs/puppeteer/common/NetworkManager.js"],"names":["Object","defineProperty","exports","value","NetworkManager","NetworkManagerEmittedEvents","EventEmitter_js_1","require","assert_js_1","helper_js_1","HTTPRequest_js_1","HTTPResponse_js_1","Request","Symbol","RequestServedFromCache","Response","RequestFailed","RequestFinished","EventEmitter","constructor","client","ignoreHTTPSErrors","frameManager","_requestIdToRequestWillBeSentEvent","Map","_requestIdToRequestPausedEvent","_requestIdToRequest","_extraHTTPHeaders","_credentials","_attemptedAuthentications","Set","_userRequestInterceptionEnabled","_protocolRequestInterceptionEnabled","_userCacheDisabled","_emulatedNetworkConditions","offline","upload","download","latency","_client","_ignoreHTTPSErrors","_frameManager","on","_onRequestPaused","bind","_onAuthRequired","_onRequestWillBeSent","_onRequestServedFromCache","_onResponseReceived","_onLoadingFinished","_onLoadingFailed","initialize","send","ignore","authenticate","credentials","_updateProtocolRequestInterception","setExtraHTTPHeaders","extraHTTPHeaders","key","keys","assert","helper","isString","toLowerCase","headers","assign","setOfflineMode","_updateNetworkConditions","emulateNetworkConditions","networkConditions","uploadThroughput","downloadThroughput","setUserAgent","userAgent","userAgentMetadata","setCacheEnabled","enabled","_updateProtocolCacheDisabled","setRequestInterception","Promise","all","handleAuthRequests","patterns","urlPattern","_cacheDisabled","cacheDisabled","event","request","url","startsWith","requestId","requestPausedEvent","get","set","interceptionId","_onRequest","delete","response","has","add","username","password","undefined","authChallengeResponse","catch","debugError","networkId","requestWillBeSentEvent","method","redirectChain","redirectResponse","_handleRequestRedirect","_redirectChain","frame","frameId","HTTPRequest","emit","finalizeInterceptions","error","_fromMemoryCache","responsePayload","HTTPResponse","_response","push","_resolveBody","Error","_forgetRequest","events","_requestId","_interceptionId","_failureText","errorText"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NetworkManager = exports.NetworkManagerEmittedEvents = void 0;\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst HTTPRequest_js_1 = require(\"./HTTPRequest.js\");\nconst HTTPResponse_js_1 = require(\"./HTTPResponse.js\");\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexports.NetworkManagerEmittedEvents = {\n    Request: Symbol('NetworkManager.Request'),\n    RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n    Response: Symbol('NetworkManager.Response'),\n    RequestFailed: Symbol('NetworkManager.RequestFailed'),\n    RequestFinished: Symbol('NetworkManager.RequestFinished'),\n};\n/**\n * @internal\n */\nclass NetworkManager extends EventEmitter_js_1.EventEmitter {\n    constructor(client, ignoreHTTPSErrors, frameManager) {\n        super();\n        /*\n         * There are four possible orders of events:\n         *  A. `_onRequestWillBeSent`\n         *  B. `_onRequestWillBeSent`, `_onRequestPaused`\n         *  C. `_onRequestPaused`, `_onRequestWillBeSent`\n         *  D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`\n         *     (see crbug.com/1196004)\n         *\n         * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n         * optionally the `interceptionId` from `_onRequestPaused`.\n         *\n         * If request interception is disabled, call `_onRequest` once per call to\n         * `_onRequestWillBeSent`.\n         * If request interception is enabled, call `_onRequest` once per call to\n         * `_onRequestPaused` (once per `interceptionId`).\n         *\n         * Events are stored to allow for subsequent events to call `_onRequest`.\n         *\n         * Note that (chains of) redirect requests have the same `requestId` (!) as\n         * the original request. We have to anticipate series of events like these:\n         *  A. `_onRequestWillBeSent`,\n         *     `_onRequestWillBeSent`, ...\n         *  B. `_onRequestWillBeSent`, `_onRequestPaused`,\n         *     `_onRequestWillBeSent`, `_onRequestPaused`, ...\n         *  C. `_onRequestWillBeSent`, `_onRequestPaused`,\n         *     `_onRequestPaused`, `_onRequestWillBeSent`, ...\n         *  D. `_onRequestPaused`, `_onRequestWillBeSent`,\n         *     `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`, ...\n         *     (see crbug.com/1196004)\n         */\n        this._requestIdToRequestWillBeSentEvent = new Map();\n        this._requestIdToRequestPausedEvent = new Map();\n        this._requestIdToRequest = new Map();\n        this._extraHTTPHeaders = {};\n        this._credentials = null;\n        this._attemptedAuthentications = new Set();\n        this._userRequestInterceptionEnabled = false;\n        this._protocolRequestInterceptionEnabled = false;\n        this._userCacheDisabled = false;\n        this._emulatedNetworkConditions = {\n            offline: false,\n            upload: -1,\n            download: -1,\n            latency: 0,\n        };\n        this._client = client;\n        this._ignoreHTTPSErrors = ignoreHTTPSErrors;\n        this._frameManager = frameManager;\n        this._client.on('Fetch.requestPaused', this._onRequestPaused.bind(this));\n        this._client.on('Fetch.authRequired', this._onAuthRequired.bind(this));\n        this._client.on('Network.requestWillBeSent', this._onRequestWillBeSent.bind(this));\n        this._client.on('Network.requestServedFromCache', this._onRequestServedFromCache.bind(this));\n        this._client.on('Network.responseReceived', this._onResponseReceived.bind(this));\n        this._client.on('Network.loadingFinished', this._onLoadingFinished.bind(this));\n        this._client.on('Network.loadingFailed', this._onLoadingFailed.bind(this));\n    }\n    async initialize() {\n        await this._client.send('Network.enable');\n        if (this._ignoreHTTPSErrors)\n            await this._client.send('Security.setIgnoreCertificateErrors', {\n                ignore: true,\n            });\n    }\n    async authenticate(credentials) {\n        this._credentials = credentials;\n        await this._updateProtocolRequestInterception();\n    }\n    async setExtraHTTPHeaders(extraHTTPHeaders) {\n        this._extraHTTPHeaders = {};\n        for (const key of Object.keys(extraHTTPHeaders)) {\n            const value = extraHTTPHeaders[key];\n            assert_js_1.assert(helper_js_1.helper.isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n            this._extraHTTPHeaders[key.toLowerCase()] = value;\n        }\n        await this._client.send('Network.setExtraHTTPHeaders', {\n            headers: this._extraHTTPHeaders,\n        });\n    }\n    extraHTTPHeaders() {\n        return Object.assign({}, this._extraHTTPHeaders);\n    }\n    async setOfflineMode(value) {\n        this._emulatedNetworkConditions.offline = value;\n        await this._updateNetworkConditions();\n    }\n    async emulateNetworkConditions(networkConditions) {\n        this._emulatedNetworkConditions.upload = networkConditions\n            ? networkConditions.upload\n            : -1;\n        this._emulatedNetworkConditions.download = networkConditions\n            ? networkConditions.download\n            : -1;\n        this._emulatedNetworkConditions.latency = networkConditions\n            ? networkConditions.latency\n            : 0;\n        await this._updateNetworkConditions();\n    }\n    async _updateNetworkConditions() {\n        await this._client.send('Network.emulateNetworkConditions', {\n            offline: this._emulatedNetworkConditions.offline,\n            latency: this._emulatedNetworkConditions.latency,\n            uploadThroughput: this._emulatedNetworkConditions.upload,\n            downloadThroughput: this._emulatedNetworkConditions.download,\n        });\n    }\n    async setUserAgent(userAgent, userAgentMetadata) {\n        await this._client.send('Network.setUserAgentOverride', {\n            userAgent: userAgent,\n            userAgentMetadata: userAgentMetadata,\n        });\n    }\n    async setCacheEnabled(enabled) {\n        this._userCacheDisabled = !enabled;\n        await this._updateProtocolCacheDisabled();\n    }\n    async setRequestInterception(value) {\n        this._userRequestInterceptionEnabled = value;\n        await this._updateProtocolRequestInterception();\n    }\n    async _updateProtocolRequestInterception() {\n        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;\n        if (enabled === this._protocolRequestInterceptionEnabled)\n            return;\n        this._protocolRequestInterceptionEnabled = enabled;\n        if (enabled) {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.enable', {\n                    handleAuthRequests: true,\n                    patterns: [{ urlPattern: '*' }],\n                }),\n            ]);\n        }\n        else {\n            await Promise.all([\n                this._updateProtocolCacheDisabled(),\n                this._client.send('Fetch.disable'),\n            ]);\n        }\n    }\n    _cacheDisabled() {\n        return this._userCacheDisabled;\n    }\n    async _updateProtocolCacheDisabled() {\n        await this._client.send('Network.setCacheDisabled', {\n            cacheDisabled: this._cacheDisabled(),\n        });\n    }\n    _onRequestWillBeSent(event) {\n        // Request interception doesn't happen for data URLs with Network Service.\n        if (this._userRequestInterceptionEnabled &&\n            !event.request.url.startsWith('data:')) {\n            const requestId = event.requestId;\n            const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);\n            this._requestIdToRequestWillBeSentEvent.set(requestId, event);\n            if (requestPausedEvent) {\n                const interceptionId = requestPausedEvent.requestId;\n                this._onRequest(event, interceptionId);\n                this._requestIdToRequestPausedEvent.delete(requestId);\n            }\n            return;\n        }\n        this._onRequest(event, null);\n    }\n    _onAuthRequired(event) {\n        let response = 'Default';\n        if (this._attemptedAuthentications.has(event.requestId)) {\n            response = 'CancelAuth';\n        }\n        else if (this._credentials) {\n            response = 'ProvideCredentials';\n            this._attemptedAuthentications.add(event.requestId);\n        }\n        const { username, password } = this._credentials || {\n            username: undefined,\n            password: undefined,\n        };\n        this._client\n            .send('Fetch.continueWithAuth', {\n            requestId: event.requestId,\n            authChallengeResponse: { response, username, password },\n        })\n            .catch(helper_js_1.debugError);\n    }\n    _onRequestPaused(event) {\n        if (!this._userRequestInterceptionEnabled &&\n            this._protocolRequestInterceptionEnabled) {\n            this._client\n                .send('Fetch.continueRequest', {\n                requestId: event.requestId,\n            })\n                .catch(helper_js_1.debugError);\n        }\n        const requestId = event.networkId;\n        const interceptionId = event.requestId;\n        if (!requestId) {\n            return;\n        }\n        let requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);\n        // redirect requests have the same `requestId`,\n        if (requestWillBeSentEvent &&\n            (requestWillBeSentEvent.request.url !== event.request.url ||\n                requestWillBeSentEvent.request.method !== event.request.method)) {\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n            requestWillBeSentEvent = null;\n        }\n        if (requestWillBeSentEvent) {\n            this._onRequest(requestWillBeSentEvent, interceptionId);\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n        }\n        else {\n            this._requestIdToRequestPausedEvent.set(requestId, event);\n        }\n    }\n    _onRequest(event, interceptionId) {\n        let redirectChain = [];\n        if (event.redirectResponse) {\n            const request = this._requestIdToRequest.get(event.requestId);\n            // If we connect late to the target, we could have missed the\n            // requestWillBeSent event.\n            if (request) {\n                this._handleRequestRedirect(request, event.redirectResponse);\n                redirectChain = request._redirectChain;\n            }\n        }\n        const frame = event.frameId\n            ? this._frameManager.frame(event.frameId)\n            : null;\n        const request = new HTTPRequest_js_1.HTTPRequest(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);\n        this._requestIdToRequest.set(event.requestId, request);\n        this.emit(exports.NetworkManagerEmittedEvents.Request, request);\n        request.finalizeInterceptions().catch((error) => {\n            // This should never happen, but catch just in case.\n            helper_js_1.debugError(error);\n        });\n    }\n    _onRequestServedFromCache(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        if (request)\n            request._fromMemoryCache = true;\n        this.emit(exports.NetworkManagerEmittedEvents.RequestServedFromCache, request);\n    }\n    _handleRequestRedirect(request, responsePayload) {\n        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, responsePayload);\n        request._response = response;\n        request._redirectChain.push(request);\n        response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n        this._forgetRequest(request, false);\n        this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onResponseReceived(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // FileUpload sends a response without a matching request.\n        if (!request)\n            return;\n        const response = new HTTPResponse_js_1.HTTPResponse(this._client, request, event.response);\n        request._response = response;\n        this.emit(exports.NetworkManagerEmittedEvents.Response, response);\n    }\n    _forgetRequest(request, events) {\n        const requestId = request._requestId;\n        const interceptionId = request._interceptionId;\n        this._requestIdToRequest.delete(requestId);\n        this._attemptedAuthentications.delete(interceptionId);\n        if (events) {\n            this._requestIdToRequestWillBeSentEvent.delete(requestId);\n            this._requestIdToRequestPausedEvent.delete(requestId);\n        }\n    }\n    _onLoadingFinished(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        // Under certain conditions we never get the Network.responseReceived\n        // event from protocol. @see https://crbug.com/883475\n        if (request.response())\n            request.response()._resolveBody(null);\n        this._forgetRequest(request, true);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFinished, request);\n    }\n    _onLoadingFailed(event) {\n        const request = this._requestIdToRequest.get(event.requestId);\n        // For certain requestIds we never receive requestWillBeSent event.\n        // @see https://crbug.com/750469\n        if (!request)\n            return;\n        request._failureText = event.errorText;\n        const response = request.response();\n        if (response)\n            response._resolveBody(null);\n        this._forgetRequest(request, true);\n        this.emit(exports.NetworkManagerEmittedEvents.RequestFailed, request);\n    }\n}\nexports.NetworkManager = NetworkManager;\n"]},"metadata":{},"sourceType":"script"}