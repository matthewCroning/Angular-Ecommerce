{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Matth\\\\workspace\\\\angular-ecommerce\\\\client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CSSCoverage = exports.JSCoverage = exports.Coverage = void 0;\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\n/**\n * The Coverage class provides methods to gathers information about parts of\n * JavaScript and CSS that were used by the page.\n *\n * @remarks\n * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},\n * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.\n *\n * @example\n * An example of using JavaScript and CSS coverage to get percentage of initially\n * executed code:\n * ```js\n * // Enable both JavaScript and CSS coverage\n * await Promise.all([\n *   page.coverage.startJSCoverage(),\n *   page.coverage.startCSSCoverage()\n * ]);\n * // Navigate to page\n * await page.goto('https://example.com');\n * // Disable both JavaScript and CSS coverage\n * const [jsCoverage, cssCoverage] = await Promise.all([\n *   page.coverage.stopJSCoverage(),\n *   page.coverage.stopCSSCoverage(),\n * ]);\n * let totalBytes = 0;\n * let usedBytes = 0;\n * const coverage = [...jsCoverage, ...cssCoverage];\n * for (const entry of coverage) {\n *   totalBytes += entry.text.length;\n *   for (const range of entry.ranges)\n *     usedBytes += range.end - range.start - 1;\n * }\n * console.log(`Bytes used: ${usedBytes / totalBytes * 100}%`);\n * ```\n * @public\n */\n\n\nclass Coverage {\n  constructor(client) {\n    this._jsCoverage = new JSCoverage(client);\n    this._cssCoverage = new CSSCoverage(client);\n  }\n  /**\n   * @param options - Set of configurable options for coverage defaults to\n   * `resetOnNavigation : true, reportAnonymousScripts : false`\n   * @returns Promise that resolves when coverage is started.\n   *\n   * @remarks\n   * Anonymous scripts are ones that don't have an associated url. These are\n   * scripts that are dynamically created on the page using `eval` or\n   * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous\n   * scripts will have `__puppeteer_evaluation_script__` as their URL.\n   */\n\n\n  startJSCoverage(options = {}) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this._jsCoverage.start(options);\n    })();\n  }\n  /**\n   * @returns Promise that resolves to the array of coverage reports for\n   * all scripts.\n   *\n   * @remarks\n   * JavaScript Coverage doesn't include anonymous scripts by default.\n   * However, scripts with sourceURLs are reported.\n   */\n\n\n  stopJSCoverage() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this2._jsCoverage.stop();\n    })();\n  }\n  /**\n   * @param options - Set of configurable options for coverage, defaults to\n   * `resetOnNavigation : true`\n   * @returns Promise that resolves when coverage is started.\n   */\n\n\n  startCSSCoverage(options = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this3._cssCoverage.start(options);\n    })();\n  }\n  /**\n   * @returns Promise that resolves to the array of coverage reports\n   * for all stylesheets.\n   * @remarks\n   * CSS Coverage doesn't include dynamically injected style tags\n   * without sourceURLs.\n   */\n\n\n  stopCSSCoverage() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      return yield _this4._cssCoverage.stop();\n    })();\n  }\n\n}\n\nexports.Coverage = Coverage;\n/**\n * @public\n */\n\nclass JSCoverage {\n  constructor(client) {\n    this._enabled = false;\n    this._scriptURLs = new Map();\n    this._scriptSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n    this._reportAnonymousScripts = false;\n    this._client = client;\n  }\n\n  start(options = {}) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      assert_js_1.assert(!_this5._enabled, 'JSCoverage is already enabled');\n      const {\n        resetOnNavigation = true,\n        reportAnonymousScripts = false\n      } = options;\n      _this5._resetOnNavigation = resetOnNavigation;\n      _this5._reportAnonymousScripts = reportAnonymousScripts;\n      _this5._enabled = true;\n\n      _this5._scriptURLs.clear();\n\n      _this5._scriptSources.clear();\n\n      _this5._eventListeners = [helper_js_1.helper.addEventListener(_this5._client, 'Debugger.scriptParsed', _this5._onScriptParsed.bind(_this5)), helper_js_1.helper.addEventListener(_this5._client, 'Runtime.executionContextsCleared', _this5._onExecutionContextsCleared.bind(_this5))];\n      yield Promise.all([_this5._client.send('Profiler.enable'), _this5._client.send('Profiler.startPreciseCoverage', {\n        callCount: false,\n        detailed: true\n      }), _this5._client.send('Debugger.enable'), _this5._client.send('Debugger.setSkipAllPauses', {\n        skip: true\n      })]);\n    })();\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation) return;\n\n    this._scriptURLs.clear();\n\n    this._scriptSources.clear();\n  }\n\n  _onScriptParsed(event) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      // Ignore puppeteer-injected scripts\n      if (event.url === ExecutionContext_js_1.EVALUATION_SCRIPT_URL) return; // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n\n      if (!event.url && !_this6._reportAnonymousScripts) return;\n\n      try {\n        const response = yield _this6._client.send('Debugger.getScriptSource', {\n          scriptId: event.scriptId\n        });\n\n        _this6._scriptURLs.set(event.scriptId, event.url);\n\n        _this6._scriptSources.set(event.scriptId, response.scriptSource);\n      } catch (error) {\n        // This might happen if the page has already navigated away.\n        helper_js_1.debugError(error);\n      }\n    })();\n  }\n\n  stop() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      assert_js_1.assert(_this7._enabled, 'JSCoverage is not enabled');\n      _this7._enabled = false;\n      const result = yield Promise.all([_this7._client.send('Profiler.takePreciseCoverage'), _this7._client.send('Profiler.stopPreciseCoverage'), _this7._client.send('Profiler.disable'), _this7._client.send('Debugger.disable')]);\n      helper_js_1.helper.removeEventListeners(_this7._eventListeners);\n      const coverage = [];\n      const profileResponse = result[0];\n\n      for (const entry of profileResponse.result) {\n        let url = _this7._scriptURLs.get(entry.scriptId);\n\n        if (!url && _this7._reportAnonymousScripts) url = 'debugger://VM' + entry.scriptId;\n\n        const text = _this7._scriptSources.get(entry.scriptId);\n\n        if (text === undefined || url === undefined) continue;\n        const flattenRanges = [];\n\n        for (const func of entry.functions) flattenRanges.push(...func.ranges);\n\n        const ranges = convertToDisjointRanges(flattenRanges);\n        coverage.push({\n          url,\n          ranges,\n          text\n        });\n      }\n\n      return coverage;\n    })();\n  }\n\n}\n\nexports.JSCoverage = JSCoverage;\n/**\n * @public\n */\n\nclass CSSCoverage {\n  constructor(client) {\n    this._enabled = false;\n    this._stylesheetURLs = new Map();\n    this._stylesheetSources = new Map();\n    this._eventListeners = [];\n    this._resetOnNavigation = false;\n    this._reportAnonymousScripts = false;\n    this._client = client;\n  }\n\n  start(options = {}) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      assert_js_1.assert(!_this8._enabled, 'CSSCoverage is already enabled');\n      const {\n        resetOnNavigation = true\n      } = options;\n      _this8._resetOnNavigation = resetOnNavigation;\n      _this8._enabled = true;\n\n      _this8._stylesheetURLs.clear();\n\n      _this8._stylesheetSources.clear();\n\n      _this8._eventListeners = [helper_js_1.helper.addEventListener(_this8._client, 'CSS.styleSheetAdded', _this8._onStyleSheet.bind(_this8)), helper_js_1.helper.addEventListener(_this8._client, 'Runtime.executionContextsCleared', _this8._onExecutionContextsCleared.bind(_this8))];\n      yield Promise.all([_this8._client.send('DOM.enable'), _this8._client.send('CSS.enable'), _this8._client.send('CSS.startRuleUsageTracking')]);\n    })();\n  }\n\n  _onExecutionContextsCleared() {\n    if (!this._resetOnNavigation) return;\n\n    this._stylesheetURLs.clear();\n\n    this._stylesheetSources.clear();\n  }\n\n  _onStyleSheet(event) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const header = event.header; // Ignore anonymous scripts\n\n      if (!header.sourceURL) return;\n\n      try {\n        const response = yield _this9._client.send('CSS.getStyleSheetText', {\n          styleSheetId: header.styleSheetId\n        });\n\n        _this9._stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n\n        _this9._stylesheetSources.set(header.styleSheetId, response.text);\n      } catch (error) {\n        // This might happen if the page has already navigated away.\n        helper_js_1.debugError(error);\n      }\n    })();\n  }\n\n  stop() {\n    var _this10 = this;\n\n    return _asyncToGenerator(function* () {\n      assert_js_1.assert(_this10._enabled, 'CSSCoverage is not enabled');\n      _this10._enabled = false;\n      const ruleTrackingResponse = yield _this10._client.send('CSS.stopRuleUsageTracking');\n      yield Promise.all([_this10._client.send('CSS.disable'), _this10._client.send('DOM.disable')]);\n      helper_js_1.helper.removeEventListeners(_this10._eventListeners); // aggregate by styleSheetId\n\n      const styleSheetIdToCoverage = new Map();\n\n      for (const entry of ruleTrackingResponse.ruleUsage) {\n        let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n\n        if (!ranges) {\n          ranges = [];\n          styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n        }\n\n        ranges.push({\n          startOffset: entry.startOffset,\n          endOffset: entry.endOffset,\n          count: entry.used ? 1 : 0\n        });\n      }\n\n      const coverage = [];\n\n      for (const styleSheetId of _this10._stylesheetURLs.keys()) {\n        const url = _this10._stylesheetURLs.get(styleSheetId);\n\n        const text = _this10._stylesheetSources.get(styleSheetId);\n\n        const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n        coverage.push({\n          url,\n          ranges,\n          text\n        });\n      }\n\n      return coverage;\n    })();\n  }\n\n}\n\nexports.CSSCoverage = CSSCoverage;\n\nfunction convertToDisjointRanges(nestedRanges) {\n  const points = [];\n\n  for (const range of nestedRanges) {\n    points.push({\n      offset: range.startOffset,\n      type: 0,\n      range\n    });\n    points.push({\n      offset: range.endOffset,\n      type: 1,\n      range\n    });\n  } // Sort points to form a valid parenthesis sequence.\n\n\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset) return a.offset - b.offset; // All \"end\" points should go before \"start\" points.\n\n    if (a.type !== b.type) return b.type - a.type;\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset; // For two \"start\" points, the one with longer range goes first.\n\n    if (a.type === 0) return bLength - aLength; // For two \"end\" points, the one with shorter range goes first.\n\n    return aLength - bLength;\n  });\n  const hitCountStack = [];\n  const results = [];\n  let lastOffset = 0; // Run scanning line to intersect all ranges.\n\n  for (const point of points) {\n    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {\n      const lastResult = results.length ? results[results.length - 1] : null;\n      if (lastResult && lastResult.end === lastOffset) lastResult.end = point.offset;else results.push({\n        start: lastOffset,\n        end: point.offset\n      });\n    }\n\n    lastOffset = point.offset;\n    if (point.type === 0) hitCountStack.push(point.range.count);else hitCountStack.pop();\n  } // Filter out empty ranges.\n\n\n  return results.filter(range => range.end - range.start > 1);\n}","map":{"version":3,"sources":["C:/Users/Matth/workspace/node_modules/puppeteer/lib/cjs/puppeteer/common/Coverage.js"],"names":["Object","defineProperty","exports","value","CSSCoverage","JSCoverage","Coverage","assert_js_1","require","helper_js_1","ExecutionContext_js_1","constructor","client","_jsCoverage","_cssCoverage","startJSCoverage","options","start","stopJSCoverage","stop","startCSSCoverage","stopCSSCoverage","_enabled","_scriptURLs","Map","_scriptSources","_eventListeners","_resetOnNavigation","_reportAnonymousScripts","_client","assert","resetOnNavigation","reportAnonymousScripts","clear","helper","addEventListener","_onScriptParsed","bind","_onExecutionContextsCleared","Promise","all","send","callCount","detailed","skip","event","url","EVALUATION_SCRIPT_URL","response","scriptId","set","scriptSource","error","debugError","result","removeEventListeners","coverage","profileResponse","entry","get","text","undefined","flattenRanges","func","functions","push","ranges","convertToDisjointRanges","_stylesheetURLs","_stylesheetSources","_onStyleSheet","header","sourceURL","styleSheetId","ruleTrackingResponse","styleSheetIdToCoverage","ruleUsage","startOffset","endOffset","count","used","keys","nestedRanges","points","range","offset","type","sort","a","b","aLength","bLength","hitCountStack","results","lastOffset","point","length","lastResult","end","pop","filter"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,WAAR,GAAsBF,OAAO,CAACG,UAAR,GAAqBH,OAAO,CAACI,QAAR,GAAmB,KAAK,CAAnE;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAME,qBAAqB,GAAGF,OAAO,CAAC,uBAAD,CAArC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMF,QAAN,CAAe;AACXK,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,SAAKC,WAAL,GAAmB,IAAIR,UAAJ,CAAeO,MAAf,CAAnB;AACA,SAAKE,YAAL,GAAoB,IAAIV,WAAJ,CAAgBQ,MAAhB,CAApB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUG,EAAAA,eAAe,CAACC,OAAO,GAAG,EAAX,EAAe;AAAA;;AAAA;AAChC,mBAAa,KAAI,CAACH,WAAL,CAAiBI,KAAjB,CAAuBD,OAAvB,CAAb;AADgC;AAEnC;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACUE,EAAAA,cAAc,GAAG;AAAA;;AAAA;AACnB,mBAAa,MAAI,CAACL,WAAL,CAAiBM,IAAjB,EAAb;AADmB;AAEtB;AACD;AACJ;AACA;AACA;AACA;;;AACUC,EAAAA,gBAAgB,CAACJ,OAAO,GAAG,EAAX,EAAe;AAAA;;AAAA;AACjC,mBAAa,MAAI,CAACF,YAAL,CAAkBG,KAAlB,CAAwBD,OAAxB,CAAb;AADiC;AAEpC;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACUK,EAAAA,eAAe,GAAG;AAAA;;AAAA;AACpB,mBAAa,MAAI,CAACP,YAAL,CAAkBK,IAAlB,EAAb;AADoB;AAEvB;;AA/CU;;AAiDfjB,OAAO,CAACI,QAAR,GAAmBA,QAAnB;AACA;AACA;AACA;;AACA,MAAMD,UAAN,CAAiB;AACbM,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,SAAKU,QAAL,GAAgB,KAAhB;AACA,SAAKC,WAAL,GAAmB,IAAIC,GAAJ,EAAnB;AACA,SAAKC,cAAL,GAAsB,IAAID,GAAJ,EAAtB;AACA,SAAKE,eAAL,GAAuB,EAAvB;AACA,SAAKC,kBAAL,GAA0B,KAA1B;AACA,SAAKC,uBAAL,GAA+B,KAA/B;AACA,SAAKC,OAAL,GAAejB,MAAf;AACH;;AACKK,EAAAA,KAAK,CAACD,OAAO,GAAG,EAAX,EAAe;AAAA;;AAAA;AACtBT,MAAAA,WAAW,CAACuB,MAAZ,CAAmB,CAAC,MAAI,CAACR,QAAzB,EAAmC,+BAAnC;AACA,YAAM;AAAES,QAAAA,iBAAiB,GAAG,IAAtB;AAA4BC,QAAAA,sBAAsB,GAAG;AAArD,UAA+DhB,OAArE;AACA,MAAA,MAAI,CAACW,kBAAL,GAA0BI,iBAA1B;AACA,MAAA,MAAI,CAACH,uBAAL,GAA+BI,sBAA/B;AACA,MAAA,MAAI,CAACV,QAAL,GAAgB,IAAhB;;AACA,MAAA,MAAI,CAACC,WAAL,CAAiBU,KAAjB;;AACA,MAAA,MAAI,CAACR,cAAL,CAAoBQ,KAApB;;AACA,MAAA,MAAI,CAACP,eAAL,GAAuB,CACnBjB,WAAW,CAACyB,MAAZ,CAAmBC,gBAAnB,CAAoC,MAAI,CAACN,OAAzC,EAAkD,uBAAlD,EAA2E,MAAI,CAACO,eAAL,CAAqBC,IAArB,CAA0B,MAA1B,CAA3E,CADmB,EAEnB5B,WAAW,CAACyB,MAAZ,CAAmBC,gBAAnB,CAAoC,MAAI,CAACN,OAAzC,EAAkD,kCAAlD,EAAsF,MAAI,CAACS,2BAAL,CAAiCD,IAAjC,CAAsC,MAAtC,CAAtF,CAFmB,CAAvB;AAIA,YAAME,OAAO,CAACC,GAAR,CAAY,CACd,MAAI,CAACX,OAAL,CAAaY,IAAb,CAAkB,iBAAlB,CADc,EAEd,MAAI,CAACZ,OAAL,CAAaY,IAAb,CAAkB,+BAAlB,EAAmD;AAC/CC,QAAAA,SAAS,EAAE,KADoC;AAE/CC,QAAAA,QAAQ,EAAE;AAFqC,OAAnD,CAFc,EAMd,MAAI,CAACd,OAAL,CAAaY,IAAb,CAAkB,iBAAlB,CANc,EAOd,MAAI,CAACZ,OAAL,CAAaY,IAAb,CAAkB,2BAAlB,EAA+C;AAAEG,QAAAA,IAAI,EAAE;AAAR,OAA/C,CAPc,CAAZ,CAAN;AAZsB;AAqBzB;;AACDN,EAAAA,2BAA2B,GAAG;AAC1B,QAAI,CAAC,KAAKX,kBAAV,EACI;;AACJ,SAAKJ,WAAL,CAAiBU,KAAjB;;AACA,SAAKR,cAAL,CAAoBQ,KAApB;AACH;;AACKG,EAAAA,eAAe,CAACS,KAAD,EAAQ;AAAA;;AAAA;AACzB;AACA,UAAIA,KAAK,CAACC,GAAN,KAAcpC,qBAAqB,CAACqC,qBAAxC,EACI,OAHqB,CAIzB;;AACA,UAAI,CAACF,KAAK,CAACC,GAAP,IAAc,CAAC,MAAI,CAAClB,uBAAxB,EACI;;AACJ,UAAI;AACA,cAAMoB,QAAQ,SAAS,MAAI,CAACnB,OAAL,CAAaY,IAAb,CAAkB,0BAAlB,EAA8C;AACjEQ,UAAAA,QAAQ,EAAEJ,KAAK,CAACI;AADiD,SAA9C,CAAvB;;AAGA,QAAA,MAAI,CAAC1B,WAAL,CAAiB2B,GAAjB,CAAqBL,KAAK,CAACI,QAA3B,EAAqCJ,KAAK,CAACC,GAA3C;;AACA,QAAA,MAAI,CAACrB,cAAL,CAAoByB,GAApB,CAAwBL,KAAK,CAACI,QAA9B,EAAwCD,QAAQ,CAACG,YAAjD;AACH,OAND,CAOA,OAAOC,KAAP,EAAc;AACV;AACA3C,QAAAA,WAAW,CAAC4C,UAAZ,CAAuBD,KAAvB;AACH;AAjBwB;AAkB5B;;AACKjC,EAAAA,IAAI,GAAG;AAAA;;AAAA;AACTZ,MAAAA,WAAW,CAACuB,MAAZ,CAAmB,MAAI,CAACR,QAAxB,EAAkC,2BAAlC;AACA,MAAA,MAAI,CAACA,QAAL,GAAgB,KAAhB;AACA,YAAMgC,MAAM,SAASf,OAAO,CAACC,GAAR,CAAY,CAC7B,MAAI,CAACX,OAAL,CAAaY,IAAb,CAAkB,8BAAlB,CAD6B,EAE7B,MAAI,CAACZ,OAAL,CAAaY,IAAb,CAAkB,8BAAlB,CAF6B,EAG7B,MAAI,CAACZ,OAAL,CAAaY,IAAb,CAAkB,kBAAlB,CAH6B,EAI7B,MAAI,CAACZ,OAAL,CAAaY,IAAb,CAAkB,kBAAlB,CAJ6B,CAAZ,CAArB;AAMAhC,MAAAA,WAAW,CAACyB,MAAZ,CAAmBqB,oBAAnB,CAAwC,MAAI,CAAC7B,eAA7C;AACA,YAAM8B,QAAQ,GAAG,EAAjB;AACA,YAAMC,eAAe,GAAGH,MAAM,CAAC,CAAD,CAA9B;;AACA,WAAK,MAAMI,KAAX,IAAoBD,eAAe,CAACH,MAApC,EAA4C;AACxC,YAAIR,GAAG,GAAG,MAAI,CAACvB,WAAL,CAAiBoC,GAAjB,CAAqBD,KAAK,CAACT,QAA3B,CAAV;;AACA,YAAI,CAACH,GAAD,IAAQ,MAAI,CAAClB,uBAAjB,EACIkB,GAAG,GAAG,kBAAkBY,KAAK,CAACT,QAA9B;;AACJ,cAAMW,IAAI,GAAG,MAAI,CAACnC,cAAL,CAAoBkC,GAApB,CAAwBD,KAAK,CAACT,QAA9B,CAAb;;AACA,YAAIW,IAAI,KAAKC,SAAT,IAAsBf,GAAG,KAAKe,SAAlC,EACI;AACJ,cAAMC,aAAa,GAAG,EAAtB;;AACA,aAAK,MAAMC,IAAX,IAAmBL,KAAK,CAACM,SAAzB,EACIF,aAAa,CAACG,IAAd,CAAmB,GAAGF,IAAI,CAACG,MAA3B;;AACJ,cAAMA,MAAM,GAAGC,uBAAuB,CAACL,aAAD,CAAtC;AACAN,QAAAA,QAAQ,CAACS,IAAT,CAAc;AAAEnB,UAAAA,GAAF;AAAOoB,UAAAA,MAAP;AAAeN,UAAAA;AAAf,SAAd;AACH;;AACD,aAAOJ,QAAP;AAzBS;AA0BZ;;AAnFY;;AAqFjBtD,OAAO,CAACG,UAAR,GAAqBA,UAArB;AACA;AACA;AACA;;AACA,MAAMD,WAAN,CAAkB;AACdO,EAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,SAAKU,QAAL,GAAgB,KAAhB;AACA,SAAK8C,eAAL,GAAuB,IAAI5C,GAAJ,EAAvB;AACA,SAAK6C,kBAAL,GAA0B,IAAI7C,GAAJ,EAA1B;AACA,SAAKE,eAAL,GAAuB,EAAvB;AACA,SAAKC,kBAAL,GAA0B,KAA1B;AACA,SAAKC,uBAAL,GAA+B,KAA/B;AACA,SAAKC,OAAL,GAAejB,MAAf;AACH;;AACKK,EAAAA,KAAK,CAACD,OAAO,GAAG,EAAX,EAAe;AAAA;;AAAA;AACtBT,MAAAA,WAAW,CAACuB,MAAZ,CAAmB,CAAC,MAAI,CAACR,QAAzB,EAAmC,gCAAnC;AACA,YAAM;AAAES,QAAAA,iBAAiB,GAAG;AAAtB,UAA+Bf,OAArC;AACA,MAAA,MAAI,CAACW,kBAAL,GAA0BI,iBAA1B;AACA,MAAA,MAAI,CAACT,QAAL,GAAgB,IAAhB;;AACA,MAAA,MAAI,CAAC8C,eAAL,CAAqBnC,KAArB;;AACA,MAAA,MAAI,CAACoC,kBAAL,CAAwBpC,KAAxB;;AACA,MAAA,MAAI,CAACP,eAAL,GAAuB,CACnBjB,WAAW,CAACyB,MAAZ,CAAmBC,gBAAnB,CAAoC,MAAI,CAACN,OAAzC,EAAkD,qBAAlD,EAAyE,MAAI,CAACyC,aAAL,CAAmBjC,IAAnB,CAAwB,MAAxB,CAAzE,CADmB,EAEnB5B,WAAW,CAACyB,MAAZ,CAAmBC,gBAAnB,CAAoC,MAAI,CAACN,OAAzC,EAAkD,kCAAlD,EAAsF,MAAI,CAACS,2BAAL,CAAiCD,IAAjC,CAAsC,MAAtC,CAAtF,CAFmB,CAAvB;AAIA,YAAME,OAAO,CAACC,GAAR,CAAY,CACd,MAAI,CAACX,OAAL,CAAaY,IAAb,CAAkB,YAAlB,CADc,EAEd,MAAI,CAACZ,OAAL,CAAaY,IAAb,CAAkB,YAAlB,CAFc,EAGd,MAAI,CAACZ,OAAL,CAAaY,IAAb,CAAkB,4BAAlB,CAHc,CAAZ,CAAN;AAXsB;AAgBzB;;AACDH,EAAAA,2BAA2B,GAAG;AAC1B,QAAI,CAAC,KAAKX,kBAAV,EACI;;AACJ,SAAKyC,eAAL,CAAqBnC,KAArB;;AACA,SAAKoC,kBAAL,CAAwBpC,KAAxB;AACH;;AACKqC,EAAAA,aAAa,CAACzB,KAAD,EAAQ;AAAA;;AAAA;AACvB,YAAM0B,MAAM,GAAG1B,KAAK,CAAC0B,MAArB,CADuB,CAEvB;;AACA,UAAI,CAACA,MAAM,CAACC,SAAZ,EACI;;AACJ,UAAI;AACA,cAAMxB,QAAQ,SAAS,MAAI,CAACnB,OAAL,CAAaY,IAAb,CAAkB,uBAAlB,EAA2C;AAC9DgC,UAAAA,YAAY,EAAEF,MAAM,CAACE;AADyC,SAA3C,CAAvB;;AAGA,QAAA,MAAI,CAACL,eAAL,CAAqBlB,GAArB,CAAyBqB,MAAM,CAACE,YAAhC,EAA8CF,MAAM,CAACC,SAArD;;AACA,QAAA,MAAI,CAACH,kBAAL,CAAwBnB,GAAxB,CAA4BqB,MAAM,CAACE,YAAnC,EAAiDzB,QAAQ,CAACY,IAA1D;AACH,OAND,CAOA,OAAOR,KAAP,EAAc;AACV;AACA3C,QAAAA,WAAW,CAAC4C,UAAZ,CAAuBD,KAAvB;AACH;AAfsB;AAgB1B;;AACKjC,EAAAA,IAAI,GAAG;AAAA;;AAAA;AACTZ,MAAAA,WAAW,CAACuB,MAAZ,CAAmB,OAAI,CAACR,QAAxB,EAAkC,4BAAlC;AACA,MAAA,OAAI,CAACA,QAAL,GAAgB,KAAhB;AACA,YAAMoD,oBAAoB,SAAS,OAAI,CAAC7C,OAAL,CAAaY,IAAb,CAAkB,2BAAlB,CAAnC;AACA,YAAMF,OAAO,CAACC,GAAR,CAAY,CACd,OAAI,CAACX,OAAL,CAAaY,IAAb,CAAkB,aAAlB,CADc,EAEd,OAAI,CAACZ,OAAL,CAAaY,IAAb,CAAkB,aAAlB,CAFc,CAAZ,CAAN;AAIAhC,MAAAA,WAAW,CAACyB,MAAZ,CAAmBqB,oBAAnB,CAAwC,OAAI,CAAC7B,eAA7C,EARS,CAST;;AACA,YAAMiD,sBAAsB,GAAG,IAAInD,GAAJ,EAA/B;;AACA,WAAK,MAAMkC,KAAX,IAAoBgB,oBAAoB,CAACE,SAAzC,EAAoD;AAChD,YAAIV,MAAM,GAAGS,sBAAsB,CAAChB,GAAvB,CAA2BD,KAAK,CAACe,YAAjC,CAAb;;AACA,YAAI,CAACP,MAAL,EAAa;AACTA,UAAAA,MAAM,GAAG,EAAT;AACAS,UAAAA,sBAAsB,CAACzB,GAAvB,CAA2BQ,KAAK,CAACe,YAAjC,EAA+CP,MAA/C;AACH;;AACDA,QAAAA,MAAM,CAACD,IAAP,CAAY;AACRY,UAAAA,WAAW,EAAEnB,KAAK,CAACmB,WADX;AAERC,UAAAA,SAAS,EAAEpB,KAAK,CAACoB,SAFT;AAGRC,UAAAA,KAAK,EAAErB,KAAK,CAACsB,IAAN,GAAa,CAAb,GAAiB;AAHhB,SAAZ;AAKH;;AACD,YAAMxB,QAAQ,GAAG,EAAjB;;AACA,WAAK,MAAMiB,YAAX,IAA2B,OAAI,CAACL,eAAL,CAAqBa,IAArB,EAA3B,EAAwD;AACpD,cAAMnC,GAAG,GAAG,OAAI,CAACsB,eAAL,CAAqBT,GAArB,CAAyBc,YAAzB,CAAZ;;AACA,cAAMb,IAAI,GAAG,OAAI,CAACS,kBAAL,CAAwBV,GAAxB,CAA4Bc,YAA5B,CAAb;;AACA,cAAMP,MAAM,GAAGC,uBAAuB,CAACQ,sBAAsB,CAAChB,GAAvB,CAA2Bc,YAA3B,KAA4C,EAA7C,CAAtC;AACAjB,QAAAA,QAAQ,CAACS,IAAT,CAAc;AAAEnB,UAAAA,GAAF;AAAOoB,UAAAA,MAAP;AAAeN,UAAAA;AAAf,SAAd;AACH;;AACD,aAAOJ,QAAP;AA9BS;AA+BZ;;AAjFa;;AAmFlBtD,OAAO,CAACE,WAAR,GAAsBA,WAAtB;;AACA,SAAS+D,uBAAT,CAAiCe,YAAjC,EAA+C;AAC3C,QAAMC,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMC,KAAX,IAAoBF,YAApB,EAAkC;AAC9BC,IAAAA,MAAM,CAAClB,IAAP,CAAY;AAAEoB,MAAAA,MAAM,EAAED,KAAK,CAACP,WAAhB;AAA6BS,MAAAA,IAAI,EAAE,CAAnC;AAAsCF,MAAAA;AAAtC,KAAZ;AACAD,IAAAA,MAAM,CAAClB,IAAP,CAAY;AAAEoB,MAAAA,MAAM,EAAED,KAAK,CAACN,SAAhB;AAA2BQ,MAAAA,IAAI,EAAE,CAAjC;AAAoCF,MAAAA;AAApC,KAAZ;AACH,GAL0C,CAM3C;;;AACAD,EAAAA,MAAM,CAACI,IAAP,CAAY,CAACC,CAAD,EAAIC,CAAJ,KAAU;AAClB;AACA,QAAID,CAAC,CAACH,MAAF,KAAaI,CAAC,CAACJ,MAAnB,EACI,OAAOG,CAAC,CAACH,MAAF,GAAWI,CAAC,CAACJ,MAApB,CAHc,CAIlB;;AACA,QAAIG,CAAC,CAACF,IAAF,KAAWG,CAAC,CAACH,IAAjB,EACI,OAAOG,CAAC,CAACH,IAAF,GAASE,CAAC,CAACF,IAAlB;AACJ,UAAMI,OAAO,GAAGF,CAAC,CAACJ,KAAF,CAAQN,SAAR,GAAoBU,CAAC,CAACJ,KAAF,CAAQP,WAA5C;AACA,UAAMc,OAAO,GAAGF,CAAC,CAACL,KAAF,CAAQN,SAAR,GAAoBW,CAAC,CAACL,KAAF,CAAQP,WAA5C,CARkB,CASlB;;AACA,QAAIW,CAAC,CAACF,IAAF,KAAW,CAAf,EACI,OAAOK,OAAO,GAAGD,OAAjB,CAXc,CAYlB;;AACA,WAAOA,OAAO,GAAGC,OAAjB;AACH,GAdD;AAeA,QAAMC,aAAa,GAAG,EAAtB;AACA,QAAMC,OAAO,GAAG,EAAhB;AACA,MAAIC,UAAU,GAAG,CAAjB,CAxB2C,CAyB3C;;AACA,OAAK,MAAMC,KAAX,IAAoBZ,MAApB,EAA4B;AACxB,QAAIS,aAAa,CAACI,MAAd,IACAF,UAAU,GAAGC,KAAK,CAACV,MADnB,IAEAO,aAAa,CAACA,aAAa,CAACI,MAAd,GAAuB,CAAxB,CAAb,GAA0C,CAF9C,EAEiD;AAC7C,YAAMC,UAAU,GAAGJ,OAAO,CAACG,MAAR,GAAiBH,OAAO,CAACA,OAAO,CAACG,MAAR,GAAiB,CAAlB,CAAxB,GAA+C,IAAlE;AACA,UAAIC,UAAU,IAAIA,UAAU,CAACC,GAAX,KAAmBJ,UAArC,EACIG,UAAU,CAACC,GAAX,GAAiBH,KAAK,CAACV,MAAvB,CADJ,KAGIQ,OAAO,CAAC5B,IAAR,CAAa;AAAEhD,QAAAA,KAAK,EAAE6E,UAAT;AAAqBI,QAAAA,GAAG,EAAEH,KAAK,CAACV;AAAhC,OAAb;AACP;;AACDS,IAAAA,UAAU,GAAGC,KAAK,CAACV,MAAnB;AACA,QAAIU,KAAK,CAACT,IAAN,KAAe,CAAnB,EACIM,aAAa,CAAC3B,IAAd,CAAmB8B,KAAK,CAACX,KAAN,CAAYL,KAA/B,EADJ,KAGIa,aAAa,CAACO,GAAd;AACP,GAzC0C,CA0C3C;;;AACA,SAAON,OAAO,CAACO,MAAR,CAAgBhB,KAAD,IAAWA,KAAK,CAACc,GAAN,GAAYd,KAAK,CAACnE,KAAlB,GAA0B,CAApD,CAAP;AACH","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CSSCoverage = exports.JSCoverage = exports.Coverage = void 0;\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\n/**\n * The Coverage class provides methods to gathers information about parts of\n * JavaScript and CSS that were used by the page.\n *\n * @remarks\n * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},\n * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.\n *\n * @example\n * An example of using JavaScript and CSS coverage to get percentage of initially\n * executed code:\n * ```js\n * // Enable both JavaScript and CSS coverage\n * await Promise.all([\n *   page.coverage.startJSCoverage(),\n *   page.coverage.startCSSCoverage()\n * ]);\n * // Navigate to page\n * await page.goto('https://example.com');\n * // Disable both JavaScript and CSS coverage\n * const [jsCoverage, cssCoverage] = await Promise.all([\n *   page.coverage.stopJSCoverage(),\n *   page.coverage.stopCSSCoverage(),\n * ]);\n * let totalBytes = 0;\n * let usedBytes = 0;\n * const coverage = [...jsCoverage, ...cssCoverage];\n * for (const entry of coverage) {\n *   totalBytes += entry.text.length;\n *   for (const range of entry.ranges)\n *     usedBytes += range.end - range.start - 1;\n * }\n * console.log(`Bytes used: ${usedBytes / totalBytes * 100}%`);\n * ```\n * @public\n */\nclass Coverage {\n    constructor(client) {\n        this._jsCoverage = new JSCoverage(client);\n        this._cssCoverage = new CSSCoverage(client);\n    }\n    /**\n     * @param options - Set of configurable options for coverage defaults to\n     * `resetOnNavigation : true, reportAnonymousScripts : false`\n     * @returns Promise that resolves when coverage is started.\n     *\n     * @remarks\n     * Anonymous scripts are ones that don't have an associated url. These are\n     * scripts that are dynamically created on the page using `eval` or\n     * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous\n     * scripts will have `__puppeteer_evaluation_script__` as their URL.\n     */\n    async startJSCoverage(options = {}) {\n        return await this._jsCoverage.start(options);\n    }\n    /**\n     * @returns Promise that resolves to the array of coverage reports for\n     * all scripts.\n     *\n     * @remarks\n     * JavaScript Coverage doesn't include anonymous scripts by default.\n     * However, scripts with sourceURLs are reported.\n     */\n    async stopJSCoverage() {\n        return await this._jsCoverage.stop();\n    }\n    /**\n     * @param options - Set of configurable options for coverage, defaults to\n     * `resetOnNavigation : true`\n     * @returns Promise that resolves when coverage is started.\n     */\n    async startCSSCoverage(options = {}) {\n        return await this._cssCoverage.start(options);\n    }\n    /**\n     * @returns Promise that resolves to the array of coverage reports\n     * for all stylesheets.\n     * @remarks\n     * CSS Coverage doesn't include dynamically injected style tags\n     * without sourceURLs.\n     */\n    async stopCSSCoverage() {\n        return await this._cssCoverage.stop();\n    }\n}\nexports.Coverage = Coverage;\n/**\n * @public\n */\nclass JSCoverage {\n    constructor(client) {\n        this._enabled = false;\n        this._scriptURLs = new Map();\n        this._scriptSources = new Map();\n        this._eventListeners = [];\n        this._resetOnNavigation = false;\n        this._reportAnonymousScripts = false;\n        this._client = client;\n    }\n    async start(options = {}) {\n        assert_js_1.assert(!this._enabled, 'JSCoverage is already enabled');\n        const { resetOnNavigation = true, reportAnonymousScripts = false } = options;\n        this._resetOnNavigation = resetOnNavigation;\n        this._reportAnonymousScripts = reportAnonymousScripts;\n        this._enabled = true;\n        this._scriptURLs.clear();\n        this._scriptSources.clear();\n        this._eventListeners = [\n            helper_js_1.helper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)),\n            helper_js_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n        ];\n        await Promise.all([\n            this._client.send('Profiler.enable'),\n            this._client.send('Profiler.startPreciseCoverage', {\n                callCount: false,\n                detailed: true,\n            }),\n            this._client.send('Debugger.enable'),\n            this._client.send('Debugger.setSkipAllPauses', { skip: true }),\n        ]);\n    }\n    _onExecutionContextsCleared() {\n        if (!this._resetOnNavigation)\n            return;\n        this._scriptURLs.clear();\n        this._scriptSources.clear();\n    }\n    async _onScriptParsed(event) {\n        // Ignore puppeteer-injected scripts\n        if (event.url === ExecutionContext_js_1.EVALUATION_SCRIPT_URL)\n            return;\n        // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n        if (!event.url && !this._reportAnonymousScripts)\n            return;\n        try {\n            const response = await this._client.send('Debugger.getScriptSource', {\n                scriptId: event.scriptId,\n            });\n            this._scriptURLs.set(event.scriptId, event.url);\n            this._scriptSources.set(event.scriptId, response.scriptSource);\n        }\n        catch (error) {\n            // This might happen if the page has already navigated away.\n            helper_js_1.debugError(error);\n        }\n    }\n    async stop() {\n        assert_js_1.assert(this._enabled, 'JSCoverage is not enabled');\n        this._enabled = false;\n        const result = await Promise.all([\n            this._client.send('Profiler.takePreciseCoverage'),\n            this._client.send('Profiler.stopPreciseCoverage'),\n            this._client.send('Profiler.disable'),\n            this._client.send('Debugger.disable'),\n        ]);\n        helper_js_1.helper.removeEventListeners(this._eventListeners);\n        const coverage = [];\n        const profileResponse = result[0];\n        for (const entry of profileResponse.result) {\n            let url = this._scriptURLs.get(entry.scriptId);\n            if (!url && this._reportAnonymousScripts)\n                url = 'debugger://VM' + entry.scriptId;\n            const text = this._scriptSources.get(entry.scriptId);\n            if (text === undefined || url === undefined)\n                continue;\n            const flattenRanges = [];\n            for (const func of entry.functions)\n                flattenRanges.push(...func.ranges);\n            const ranges = convertToDisjointRanges(flattenRanges);\n            coverage.push({ url, ranges, text });\n        }\n        return coverage;\n    }\n}\nexports.JSCoverage = JSCoverage;\n/**\n * @public\n */\nclass CSSCoverage {\n    constructor(client) {\n        this._enabled = false;\n        this._stylesheetURLs = new Map();\n        this._stylesheetSources = new Map();\n        this._eventListeners = [];\n        this._resetOnNavigation = false;\n        this._reportAnonymousScripts = false;\n        this._client = client;\n    }\n    async start(options = {}) {\n        assert_js_1.assert(!this._enabled, 'CSSCoverage is already enabled');\n        const { resetOnNavigation = true } = options;\n        this._resetOnNavigation = resetOnNavigation;\n        this._enabled = true;\n        this._stylesheetURLs.clear();\n        this._stylesheetSources.clear();\n        this._eventListeners = [\n            helper_js_1.helper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)),\n            helper_js_1.helper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)),\n        ];\n        await Promise.all([\n            this._client.send('DOM.enable'),\n            this._client.send('CSS.enable'),\n            this._client.send('CSS.startRuleUsageTracking'),\n        ]);\n    }\n    _onExecutionContextsCleared() {\n        if (!this._resetOnNavigation)\n            return;\n        this._stylesheetURLs.clear();\n        this._stylesheetSources.clear();\n    }\n    async _onStyleSheet(event) {\n        const header = event.header;\n        // Ignore anonymous scripts\n        if (!header.sourceURL)\n            return;\n        try {\n            const response = await this._client.send('CSS.getStyleSheetText', {\n                styleSheetId: header.styleSheetId,\n            });\n            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);\n            this._stylesheetSources.set(header.styleSheetId, response.text);\n        }\n        catch (error) {\n            // This might happen if the page has already navigated away.\n            helper_js_1.debugError(error);\n        }\n    }\n    async stop() {\n        assert_js_1.assert(this._enabled, 'CSSCoverage is not enabled');\n        this._enabled = false;\n        const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');\n        await Promise.all([\n            this._client.send('CSS.disable'),\n            this._client.send('DOM.disable'),\n        ]);\n        helper_js_1.helper.removeEventListeners(this._eventListeners);\n        // aggregate by styleSheetId\n        const styleSheetIdToCoverage = new Map();\n        for (const entry of ruleTrackingResponse.ruleUsage) {\n            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n            if (!ranges) {\n                ranges = [];\n                styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n            }\n            ranges.push({\n                startOffset: entry.startOffset,\n                endOffset: entry.endOffset,\n                count: entry.used ? 1 : 0,\n            });\n        }\n        const coverage = [];\n        for (const styleSheetId of this._stylesheetURLs.keys()) {\n            const url = this._stylesheetURLs.get(styleSheetId);\n            const text = this._stylesheetSources.get(styleSheetId);\n            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n            coverage.push({ url, ranges, text });\n        }\n        return coverage;\n    }\n}\nexports.CSSCoverage = CSSCoverage;\nfunction convertToDisjointRanges(nestedRanges) {\n    const points = [];\n    for (const range of nestedRanges) {\n        points.push({ offset: range.startOffset, type: 0, range });\n        points.push({ offset: range.endOffset, type: 1, range });\n    }\n    // Sort points to form a valid parenthesis sequence.\n    points.sort((a, b) => {\n        // Sort with increasing offsets.\n        if (a.offset !== b.offset)\n            return a.offset - b.offset;\n        // All \"end\" points should go before \"start\" points.\n        if (a.type !== b.type)\n            return b.type - a.type;\n        const aLength = a.range.endOffset - a.range.startOffset;\n        const bLength = b.range.endOffset - b.range.startOffset;\n        // For two \"start\" points, the one with longer range goes first.\n        if (a.type === 0)\n            return bLength - aLength;\n        // For two \"end\" points, the one with shorter range goes first.\n        return aLength - bLength;\n    });\n    const hitCountStack = [];\n    const results = [];\n    let lastOffset = 0;\n    // Run scanning line to intersect all ranges.\n    for (const point of points) {\n        if (hitCountStack.length &&\n            lastOffset < point.offset &&\n            hitCountStack[hitCountStack.length - 1] > 0) {\n            const lastResult = results.length ? results[results.length - 1] : null;\n            if (lastResult && lastResult.end === lastOffset)\n                lastResult.end = point.offset;\n            else\n                results.push({ start: lastOffset, end: point.offset });\n        }\n        lastOffset = point.offset;\n        if (point.type === 0)\n            hitCountStack.push(point.range.count);\n        else\n            hitCountStack.pop();\n    }\n    // Filter out empty ranges.\n    return results.filter((range) => range.end - range.start > 1);\n}\n"]},"metadata":{},"sourceType":"script"}