{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Matth\\\\workspace\\\\angular-ecommerce\\\\client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HTTPRequest = void 0;\n\nconst assert_js_1 = require(\"./assert.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n/**\n *\n * Represents an HTTP request sent by a page.\n * @remarks\n *\n * Whenever the page sends a request, such as for a network resource, the\n * following events are emitted by Puppeteer's `page`:\n *\n * - `request`:  emitted when the request is issued by the page.\n * - `requestfinished` - emitted when the response body is downloaded and the\n *   request is complete.\n *\n * If request fails at some point, then instead of `requestfinished` event the\n * `requestfailed` event is emitted.\n *\n * All of these events provide an instance of `HTTPRequest` representing the\n * request that occurred:\n *\n * ```\n * page.on('request', request => ...)\n * ```\n *\n * NOTE: HTTP Error responses, such as 404 or 503, are still successful\n * responses from HTTP standpoint, so request will complete with\n * `requestfinished` event.\n *\n * If request gets a 'redirect' response, the request is successfully finished\n * with the `requestfinished` event, and a new request is issued to a\n * redirected url.\n *\n * @public\n */\n\n\nclass HTTPRequest {\n  /**\n   * @internal\n   */\n  constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {\n    /**\n     * @internal\n     */\n    this._failureText = null;\n    /**\n     * @internal\n     */\n\n    this._response = null;\n    /**\n     * @internal\n     */\n\n    this._fromMemoryCache = false;\n    this._interceptionHandled = false;\n    this._headers = {};\n    this._client = client;\n    this._requestId = event.requestId;\n    this._isNavigationRequest = event.requestId === event.loaderId && event.type === 'Document';\n    this._interceptionId = interceptionId;\n    this._allowInterception = allowInterception;\n    this._url = event.request.url;\n    this._resourceType = event.type.toLowerCase();\n    this._method = event.request.method;\n    this._postData = event.request.postData;\n    this._frame = frame;\n    this._redirectChain = redirectChain;\n    this._continueRequestOverrides = {};\n    this._currentStrategy = 'none';\n    this._currentPriority = undefined;\n    this._interceptActions = [];\n\n    for (const key of Object.keys(event.request.headers)) this._headers[key.toLowerCase()] = event.request.headers[key];\n  }\n  /**\n   * @returns the URL of the request\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * @returns the `ContinueRequestOverrides` that will be used\n   * if the interception is allowed to continue (ie, `abort()` and\n   * `respond()` aren't called).\n   */\n\n\n  continueRequestOverrides() {\n    assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n    return this._continueRequestOverrides;\n  }\n  /**\n   * @returns The `ResponseForRequest` that gets used if the\n   * interception is allowed to respond (ie, `abort()` is not called).\n   */\n\n\n  responseForRequest() {\n    assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n    return this._responseForRequest;\n  }\n  /**\n   * @returns the most recent reason for aborting the request\n   */\n\n\n  abortErrorReason() {\n    assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n    return this._abortErrorReason;\n  }\n  /**\n   * @returns An array of the current intercept resolution strategy and priority\n   * `[strategy,priority]`. Strategy is one of: `abort`, `respond`, `continue`,\n   *  `disabled`, `none`, or `already-handled`.\n   */\n\n\n  interceptResolution() {\n    if (!this._allowInterception) return ['disabled'];\n    if (this._interceptionHandled) return ['alreay-handled'];\n    return [this._currentStrategy, this._currentPriority];\n  }\n  /**\n   * Adds an async request handler to the processing queue.\n   * Deferred handlers are not guaranteed to execute in any particular order,\n   * but they are guarnateed to resolve before the request interception\n   * is finalized.\n   */\n\n\n  enqueueInterceptAction(pendingHandler) {\n    this._interceptActions.push(pendingHandler);\n  }\n  /**\n   * Awaits pending interception handlers and then decides how to fulfill\n   * the request interception.\n   */\n\n\n  finalizeInterceptions() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this._interceptActions.reduce((promiseChain, interceptAction) => promiseChain.then(interceptAction).catch(error => {\n        // This is here so cooperative handlers that fail do not stop other handlers\n        // from running\n        helper_js_1.debugError(error);\n      }), Promise.resolve());\n\n      const [resolution] = _this.interceptResolution();\n\n      switch (resolution) {\n        case 'abort':\n          return _this._abort(_this._abortErrorReason);\n\n        case 'respond':\n          return _this._respond(_this._responseForRequest);\n\n        case 'continue':\n          return _this._continue(_this._continueRequestOverrides);\n      }\n    })();\n  }\n  /**\n   * Contains the request's resource type as it was perceived by the rendering\n   * engine.\n   */\n\n\n  resourceType() {\n    return this._resourceType;\n  }\n  /**\n   * @returns the method used (`GET`, `POST`, etc.)\n   */\n\n\n  method() {\n    return this._method;\n  }\n  /**\n   * @returns the request's post body, if any.\n   */\n\n\n  postData() {\n    return this._postData;\n  }\n  /**\n   * @returns an object with HTTP headers associated with the request. All\n   * header names are lower-case.\n   */\n\n\n  headers() {\n    return this._headers;\n  }\n  /**\n   * @returns A matching `HTTPResponse` object, or null if the response has not\n   * been received yet.\n   */\n\n\n  response() {\n    return this._response;\n  }\n  /**\n   * @returns the frame that initiated the request, or null if navigating to\n   * error pages.\n   */\n\n\n  frame() {\n    return this._frame;\n  }\n  /**\n   * @returns true if the request is the driver of the current frame's navigation.\n   */\n\n\n  isNavigationRequest() {\n    return this._isNavigationRequest;\n  }\n  /**\n   * A `redirectChain` is a chain of requests initiated to fetch a resource.\n   * @remarks\n   *\n   * `redirectChain` is shared between all the requests of the same chain.\n   *\n   * For example, if the website `http://example.com` has a single redirect to\n   * `https://example.com`, then the chain will contain one request:\n   *\n   * ```js\n   * const response = await page.goto('http://example.com');\n   * const chain = response.request().redirectChain();\n   * console.log(chain.length); // 1\n   * console.log(chain[0].url()); // 'http://example.com'\n   * ```\n   *\n   * If the website `https://google.com` has no redirects, then the chain will be empty:\n   *\n   * ```js\n   * const response = await page.goto('https://google.com');\n   * const chain = response.request().redirectChain();\n   * console.log(chain.length); // 0\n   * ```\n   *\n   * @returns the chain of requests - if a server responds with at least a\n   * single redirect, this chain will contain all requests that were redirected.\n   */\n\n\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  /**\n   * Access information about the request's failure.\n   *\n   * @remarks\n   *\n   * @example\n   *\n   * Example of logging all failed requests:\n   *\n   * ```js\n   * page.on('requestfailed', request => {\n   *   console.log(request.url() + ' ' + request.failure().errorText);\n   * });\n   * ```\n   *\n   * @returns `null` unless the request failed. If the request fails this can\n   * return an object with `errorText` containing a human-readable error\n   * message, e.g. `net::ERR_FAILED`. It is not guaranteeded that there will be\n   * failure text if the request fails.\n   */\n\n\n  failure() {\n    if (!this._failureText) return null;\n    return {\n      errorText: this._failureText\n    };\n  }\n  /**\n   * Continues request with optional request overrides.\n   *\n   * @remarks\n   *\n   * To use this, request\n   * interception should be enabled with {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   *\n   * @example\n   * ```js\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   // Override headers\n   *   const headers = Object.assign({}, request.headers(), {\n   *     foo: 'bar', // set \"foo\" header\n   *     origin: undefined, // remove \"origin\" header\n   *   });\n   *   request.continue({headers});\n   * });\n   * ```\n   *\n   * @param overrides - optional overrides to apply to the request.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   */\n\n\n  continue(overrides = {}, priority) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // Request interception is not supported for data: urls.\n      if (_this2._url.startsWith('data:')) return;\n      assert_js_1.assert(_this2._allowInterception, 'Request Interception is not enabled!');\n      assert_js_1.assert(!_this2._interceptionHandled, 'Request is already handled!');\n\n      if (priority === undefined) {\n        return _this2._continue(overrides);\n      }\n\n      _this2._continueRequestOverrides = overrides;\n\n      if (priority > _this2._currentPriority || _this2._currentPriority === undefined) {\n        _this2._currentStrategy = 'continue';\n        _this2._currentPriority = priority;\n        return;\n      }\n\n      if (priority === _this2._currentPriority) {\n        if (_this2._currentStrategy === 'abort' || _this2._currentStrategy === 'respond') {\n          return;\n        }\n\n        _this2._currentStrategy = 'continue';\n      }\n\n      return;\n    })();\n  }\n\n  _continue(overrides = {}) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        url,\n        method,\n        postData,\n        headers\n      } = overrides;\n      _this3._interceptionHandled = true;\n      const postDataBinaryBase64 = postData ? Buffer.from(postData).toString('base64') : undefined;\n      yield _this3._client.send('Fetch.continueRequest', {\n        requestId: _this3._interceptionId,\n        url,\n        method,\n        postData: postDataBinaryBase64,\n        headers: headers ? headersArray(headers) : undefined\n      }).catch(error => {\n        // In certain cases, protocol will return error if the request was\n        // already canceled or the page was closed. We should tolerate these\n        // errors.\n        helper_js_1.debugError(error);\n      });\n    })();\n  }\n  /**\n   * Fulfills a request with the given response.\n   *\n   * @remarks\n   *\n   * To use this, request\n   * interception should be enabled with {@link Page.setRequestInterception}.\n   *\n   * Exception is immediately thrown if the request interception is not enabled.\n   *\n   * @example\n   * An example of fulfilling all requests with 404 responses:\n   * ```js\n   * await page.setRequestInterception(true);\n   * page.on('request', request => {\n   *   request.respond({\n   *     status: 404,\n   *     contentType: 'text/plain',\n   *     body: 'Not Found!'\n   *   });\n   * });\n   * ```\n   *\n   * NOTE: Mocking responses for dataURL requests is not supported.\n   * Calling `request.respond` for a dataURL request is a noop.\n   *\n   * @param response - the response to fulfill the request with.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   */\n\n\n  respond(response, priority) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // Mocking responses for dataURL requests is not currently supported.\n      if (_this4._url.startsWith('data:')) return;\n      assert_js_1.assert(_this4._allowInterception, 'Request Interception is not enabled!');\n      assert_js_1.assert(!_this4._interceptionHandled, 'Request is already handled!');\n\n      if (priority === undefined) {\n        return _this4._respond(response);\n      }\n\n      _this4._responseForRequest = response;\n\n      if (priority > _this4._currentPriority || _this4._currentPriority === undefined) {\n        _this4._currentStrategy = 'respond';\n        _this4._currentPriority = priority;\n        return;\n      }\n\n      if (priority === _this4._currentPriority) {\n        if (_this4._currentStrategy === 'abort') {\n          return;\n        }\n\n        _this4._currentStrategy = 'respond';\n      }\n    })();\n  }\n\n  _respond(response) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      _this5._interceptionHandled = true;\n      const responseBody = response.body && helper_js_1.helper.isString(response.body) ? Buffer.from(response.body) : response.body || null;\n      const responseHeaders = {};\n\n      if (response.headers) {\n        for (const header of Object.keys(response.headers)) responseHeaders[header.toLowerCase()] = String(response.headers[header]);\n      }\n\n      if (response.contentType) responseHeaders['content-type'] = response.contentType;\n      if (responseBody && !('content-length' in responseHeaders)) responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n      yield _this5._client.send('Fetch.fulfillRequest', {\n        requestId: _this5._interceptionId,\n        responseCode: response.status || 200,\n        responsePhrase: STATUS_TEXTS[response.status || 200],\n        responseHeaders: headersArray(responseHeaders),\n        body: responseBody ? responseBody.toString('base64') : undefined\n      }).catch(error => {\n        // In certain cases, protocol will return error if the request was\n        // already canceled or the page was closed. We should tolerate these\n        // errors.\n        helper_js_1.debugError(error);\n      });\n    })();\n  }\n  /**\n   * Aborts a request.\n   *\n   * @remarks\n   * To use this, request interception should be enabled with\n   * {@link Page.setRequestInterception}. If it is not enabled, this method will\n   * throw an exception immediately.\n   *\n   * @param errorCode - optional error code to provide.\n   * @param priority - If provided, intercept is resolved using\n   * cooperative handling rules. Otherwise, intercept is resolved\n   * immediately.\n   */\n\n\n  abort(errorCode = 'failed', priority) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      // Request interception is not supported for data: urls.\n      if (_this6._url.startsWith('data:')) return;\n      const errorReason = errorReasons[errorCode];\n      assert_js_1.assert(errorReason, 'Unknown error code: ' + errorCode);\n      assert_js_1.assert(_this6._allowInterception, 'Request Interception is not enabled!');\n      assert_js_1.assert(!_this6._interceptionHandled, 'Request is already handled!');\n\n      if (priority === undefined) {\n        return _this6._abort(errorReason);\n      }\n\n      _this6._abortErrorReason = errorReason;\n\n      if (priority >= _this6._currentPriority || _this6._currentPriority === undefined) {\n        _this6._currentStrategy = 'abort';\n        _this6._currentPriority = priority;\n        return;\n      }\n    })();\n  }\n\n  _abort(errorReason) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      _this7._interceptionHandled = true;\n      yield _this7._client.send('Fetch.failRequest', {\n        requestId: _this7._interceptionId,\n        errorReason\n      }).catch(error => {\n        // In certain cases, protocol will return error if the request was\n        // already canceled or the page was closed. We should tolerate these\n        // errors.\n        helper_js_1.debugError(error);\n      });\n    })();\n  }\n\n}\n\nexports.HTTPRequest = HTTPRequest;\nconst errorReasons = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed'\n};\n\nfunction headersArray(headers) {\n  const result = [];\n\n  for (const name in headers) {\n    if (!Object.is(headers[name], undefined)) result.push({\n      name,\n      value: headers[name] + ''\n    });\n  }\n\n  return result;\n} // List taken from\n// https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n// with extra 306 and 418 codes.\n\n\nconst STATUS_TEXTS = {\n  '100': 'Continue',\n  '101': 'Switching Protocols',\n  '102': 'Processing',\n  '103': 'Early Hints',\n  '200': 'OK',\n  '201': 'Created',\n  '202': 'Accepted',\n  '203': 'Non-Authoritative Information',\n  '204': 'No Content',\n  '205': 'Reset Content',\n  '206': 'Partial Content',\n  '207': 'Multi-Status',\n  '208': 'Already Reported',\n  '226': 'IM Used',\n  '300': 'Multiple Choices',\n  '301': 'Moved Permanently',\n  '302': 'Found',\n  '303': 'See Other',\n  '304': 'Not Modified',\n  '305': 'Use Proxy',\n  '306': 'Switch Proxy',\n  '307': 'Temporary Redirect',\n  '308': 'Permanent Redirect',\n  '400': 'Bad Request',\n  '401': 'Unauthorized',\n  '402': 'Payment Required',\n  '403': 'Forbidden',\n  '404': 'Not Found',\n  '405': 'Method Not Allowed',\n  '406': 'Not Acceptable',\n  '407': 'Proxy Authentication Required',\n  '408': 'Request Timeout',\n  '409': 'Conflict',\n  '410': 'Gone',\n  '411': 'Length Required',\n  '412': 'Precondition Failed',\n  '413': 'Payload Too Large',\n  '414': 'URI Too Long',\n  '415': 'Unsupported Media Type',\n  '416': 'Range Not Satisfiable',\n  '417': 'Expectation Failed',\n  '418': \"I'm a teapot\",\n  '421': 'Misdirected Request',\n  '422': 'Unprocessable Entity',\n  '423': 'Locked',\n  '424': 'Failed Dependency',\n  '425': 'Too Early',\n  '426': 'Upgrade Required',\n  '428': 'Precondition Required',\n  '429': 'Too Many Requests',\n  '431': 'Request Header Fields Too Large',\n  '451': 'Unavailable For Legal Reasons',\n  '500': 'Internal Server Error',\n  '501': 'Not Implemented',\n  '502': 'Bad Gateway',\n  '503': 'Service Unavailable',\n  '504': 'Gateway Timeout',\n  '505': 'HTTP Version Not Supported',\n  '506': 'Variant Also Negotiates',\n  '507': 'Insufficient Storage',\n  '508': 'Loop Detected',\n  '510': 'Not Extended',\n  '511': 'Network Authentication Required'\n};","map":{"version":3,"sources":["C:/Users/Matth/workspace/node_modules/puppeteer/lib/cjs/puppeteer/common/HTTPRequest.js"],"names":["Object","defineProperty","exports","value","HTTPRequest","assert_js_1","require","helper_js_1","constructor","client","frame","interceptionId","allowInterception","event","redirectChain","_failureText","_response","_fromMemoryCache","_interceptionHandled","_headers","_client","_requestId","requestId","_isNavigationRequest","loaderId","type","_interceptionId","_allowInterception","_url","request","url","_resourceType","toLowerCase","_method","method","_postData","postData","_frame","_redirectChain","_continueRequestOverrides","_currentStrategy","_currentPriority","undefined","_interceptActions","key","keys","headers","continueRequestOverrides","assert","responseForRequest","_responseForRequest","abortErrorReason","_abortErrorReason","interceptResolution","enqueueInterceptAction","pendingHandler","push","finalizeInterceptions","reduce","promiseChain","interceptAction","then","catch","error","debugError","Promise","resolve","resolution","_abort","_respond","_continue","resourceType","response","isNavigationRequest","slice","failure","errorText","continue","overrides","priority","startsWith","postDataBinaryBase64","Buffer","from","toString","send","headersArray","respond","responseBody","body","helper","isString","responseHeaders","header","String","contentType","byteLength","responseCode","status","responsePhrase","STATUS_TEXTS","abort","errorCode","errorReason","errorReasons","aborted","accessdenied","addressunreachable","blockedbyclient","blockedbyresponse","connectionaborted","connectionclosed","connectionfailed","connectionrefused","connectionreset","internetdisconnected","namenotresolved","timedout","failed","result","name","is"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HTTPRequest = void 0;\nconst assert_js_1 = require(\"./assert.js\");\nconst helper_js_1 = require(\"./helper.js\");\n/**\n *\n * Represents an HTTP request sent by a page.\n * @remarks\n *\n * Whenever the page sends a request, such as for a network resource, the\n * following events are emitted by Puppeteer's `page`:\n *\n * - `request`:  emitted when the request is issued by the page.\n * - `requestfinished` - emitted when the response body is downloaded and the\n *   request is complete.\n *\n * If request fails at some point, then instead of `requestfinished` event the\n * `requestfailed` event is emitted.\n *\n * All of these events provide an instance of `HTTPRequest` representing the\n * request that occurred:\n *\n * ```\n * page.on('request', request => ...)\n * ```\n *\n * NOTE: HTTP Error responses, such as 404 or 503, are still successful\n * responses from HTTP standpoint, so request will complete with\n * `requestfinished` event.\n *\n * If request gets a 'redirect' response, the request is successfully finished\n * with the `requestfinished` event, and a new request is issued to a\n * redirected url.\n *\n * @public\n */\nclass HTTPRequest {\n    /**\n     * @internal\n     */\n    constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {\n        /**\n         * @internal\n         */\n        this._failureText = null;\n        /**\n         * @internal\n         */\n        this._response = null;\n        /**\n         * @internal\n         */\n        this._fromMemoryCache = false;\n        this._interceptionHandled = false;\n        this._headers = {};\n        this._client = client;\n        this._requestId = event.requestId;\n        this._isNavigationRequest =\n            event.requestId === event.loaderId && event.type === 'Document';\n        this._interceptionId = interceptionId;\n        this._allowInterception = allowInterception;\n        this._url = event.request.url;\n        this._resourceType = event.type.toLowerCase();\n        this._method = event.request.method;\n        this._postData = event.request.postData;\n        this._frame = frame;\n        this._redirectChain = redirectChain;\n        this._continueRequestOverrides = {};\n        this._currentStrategy = 'none';\n        this._currentPriority = undefined;\n        this._interceptActions = [];\n        for (const key of Object.keys(event.request.headers))\n            this._headers[key.toLowerCase()] = event.request.headers[key];\n    }\n    /**\n     * @returns the URL of the request\n     */\n    url() {\n        return this._url;\n    }\n    /**\n     * @returns the `ContinueRequestOverrides` that will be used\n     * if the interception is allowed to continue (ie, `abort()` and\n     * `respond()` aren't called).\n     */\n    continueRequestOverrides() {\n        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n        return this._continueRequestOverrides;\n    }\n    /**\n     * @returns The `ResponseForRequest` that gets used if the\n     * interception is allowed to respond (ie, `abort()` is not called).\n     */\n    responseForRequest() {\n        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n        return this._responseForRequest;\n    }\n    /**\n     * @returns the most recent reason for aborting the request\n     */\n    abortErrorReason() {\n        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n        return this._abortErrorReason;\n    }\n    /**\n     * @returns An array of the current intercept resolution strategy and priority\n     * `[strategy,priority]`. Strategy is one of: `abort`, `respond`, `continue`,\n     *  `disabled`, `none`, or `already-handled`.\n     */\n    interceptResolution() {\n        if (!this._allowInterception)\n            return ['disabled'];\n        if (this._interceptionHandled)\n            return ['alreay-handled'];\n        return [this._currentStrategy, this._currentPriority];\n    }\n    /**\n     * Adds an async request handler to the processing queue.\n     * Deferred handlers are not guaranteed to execute in any particular order,\n     * but they are guarnateed to resolve before the request interception\n     * is finalized.\n     */\n    enqueueInterceptAction(pendingHandler) {\n        this._interceptActions.push(pendingHandler);\n    }\n    /**\n     * Awaits pending interception handlers and then decides how to fulfill\n     * the request interception.\n     */\n    async finalizeInterceptions() {\n        await this._interceptActions.reduce((promiseChain, interceptAction) => promiseChain.then(interceptAction).catch((error) => {\n            // This is here so cooperative handlers that fail do not stop other handlers\n            // from running\n            helper_js_1.debugError(error);\n        }), Promise.resolve());\n        const [resolution] = this.interceptResolution();\n        switch (resolution) {\n            case 'abort':\n                return this._abort(this._abortErrorReason);\n            case 'respond':\n                return this._respond(this._responseForRequest);\n            case 'continue':\n                return this._continue(this._continueRequestOverrides);\n        }\n    }\n    /**\n     * Contains the request's resource type as it was perceived by the rendering\n     * engine.\n     */\n    resourceType() {\n        return this._resourceType;\n    }\n    /**\n     * @returns the method used (`GET`, `POST`, etc.)\n     */\n    method() {\n        return this._method;\n    }\n    /**\n     * @returns the request's post body, if any.\n     */\n    postData() {\n        return this._postData;\n    }\n    /**\n     * @returns an object with HTTP headers associated with the request. All\n     * header names are lower-case.\n     */\n    headers() {\n        return this._headers;\n    }\n    /**\n     * @returns A matching `HTTPResponse` object, or null if the response has not\n     * been received yet.\n     */\n    response() {\n        return this._response;\n    }\n    /**\n     * @returns the frame that initiated the request, or null if navigating to\n     * error pages.\n     */\n    frame() {\n        return this._frame;\n    }\n    /**\n     * @returns true if the request is the driver of the current frame's navigation.\n     */\n    isNavigationRequest() {\n        return this._isNavigationRequest;\n    }\n    /**\n     * A `redirectChain` is a chain of requests initiated to fetch a resource.\n     * @remarks\n     *\n     * `redirectChain` is shared between all the requests of the same chain.\n     *\n     * For example, if the website `http://example.com` has a single redirect to\n     * `https://example.com`, then the chain will contain one request:\n     *\n     * ```js\n     * const response = await page.goto('http://example.com');\n     * const chain = response.request().redirectChain();\n     * console.log(chain.length); // 1\n     * console.log(chain[0].url()); // 'http://example.com'\n     * ```\n     *\n     * If the website `https://google.com` has no redirects, then the chain will be empty:\n     *\n     * ```js\n     * const response = await page.goto('https://google.com');\n     * const chain = response.request().redirectChain();\n     * console.log(chain.length); // 0\n     * ```\n     *\n     * @returns the chain of requests - if a server responds with at least a\n     * single redirect, this chain will contain all requests that were redirected.\n     */\n    redirectChain() {\n        return this._redirectChain.slice();\n    }\n    /**\n     * Access information about the request's failure.\n     *\n     * @remarks\n     *\n     * @example\n     *\n     * Example of logging all failed requests:\n     *\n     * ```js\n     * page.on('requestfailed', request => {\n     *   console.log(request.url() + ' ' + request.failure().errorText);\n     * });\n     * ```\n     *\n     * @returns `null` unless the request failed. If the request fails this can\n     * return an object with `errorText` containing a human-readable error\n     * message, e.g. `net::ERR_FAILED`. It is not guaranteeded that there will be\n     * failure text if the request fails.\n     */\n    failure() {\n        if (!this._failureText)\n            return null;\n        return {\n            errorText: this._failureText,\n        };\n    }\n    /**\n     * Continues request with optional request overrides.\n     *\n     * @remarks\n     *\n     * To use this, request\n     * interception should be enabled with {@link Page.setRequestInterception}.\n     *\n     * Exception is immediately thrown if the request interception is not enabled.\n     *\n     * @example\n     * ```js\n     * await page.setRequestInterception(true);\n     * page.on('request', request => {\n     *   // Override headers\n     *   const headers = Object.assign({}, request.headers(), {\n     *     foo: 'bar', // set \"foo\" header\n     *     origin: undefined, // remove \"origin\" header\n     *   });\n     *   request.continue({headers});\n     * });\n     * ```\n     *\n     * @param overrides - optional overrides to apply to the request.\n     * @param priority - If provided, intercept is resolved using\n     * cooperative handling rules. Otherwise, intercept is resolved\n     * immediately.\n     */\n    async continue(overrides = {}, priority) {\n        // Request interception is not supported for data: urls.\n        if (this._url.startsWith('data:'))\n            return;\n        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n        assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');\n        if (priority === undefined) {\n            return this._continue(overrides);\n        }\n        this._continueRequestOverrides = overrides;\n        if (priority > this._currentPriority ||\n            this._currentPriority === undefined) {\n            this._currentStrategy = 'continue';\n            this._currentPriority = priority;\n            return;\n        }\n        if (priority === this._currentPriority) {\n            if (this._currentStrategy === 'abort' ||\n                this._currentStrategy === 'respond') {\n                return;\n            }\n            this._currentStrategy = 'continue';\n        }\n        return;\n    }\n    async _continue(overrides = {}) {\n        const { url, method, postData, headers } = overrides;\n        this._interceptionHandled = true;\n        const postDataBinaryBase64 = postData\n            ? Buffer.from(postData).toString('base64')\n            : undefined;\n        await this._client\n            .send('Fetch.continueRequest', {\n            requestId: this._interceptionId,\n            url,\n            method,\n            postData: postDataBinaryBase64,\n            headers: headers ? headersArray(headers) : undefined,\n        })\n            .catch((error) => {\n            // In certain cases, protocol will return error if the request was\n            // already canceled or the page was closed. We should tolerate these\n            // errors.\n            helper_js_1.debugError(error);\n        });\n    }\n    /**\n     * Fulfills a request with the given response.\n     *\n     * @remarks\n     *\n     * To use this, request\n     * interception should be enabled with {@link Page.setRequestInterception}.\n     *\n     * Exception is immediately thrown if the request interception is not enabled.\n     *\n     * @example\n     * An example of fulfilling all requests with 404 responses:\n     * ```js\n     * await page.setRequestInterception(true);\n     * page.on('request', request => {\n     *   request.respond({\n     *     status: 404,\n     *     contentType: 'text/plain',\n     *     body: 'Not Found!'\n     *   });\n     * });\n     * ```\n     *\n     * NOTE: Mocking responses for dataURL requests is not supported.\n     * Calling `request.respond` for a dataURL request is a noop.\n     *\n     * @param response - the response to fulfill the request with.\n     * @param priority - If provided, intercept is resolved using\n     * cooperative handling rules. Otherwise, intercept is resolved\n     * immediately.\n     */\n    async respond(response, priority) {\n        // Mocking responses for dataURL requests is not currently supported.\n        if (this._url.startsWith('data:'))\n            return;\n        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n        assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');\n        if (priority === undefined) {\n            return this._respond(response);\n        }\n        this._responseForRequest = response;\n        if (priority > this._currentPriority ||\n            this._currentPriority === undefined) {\n            this._currentStrategy = 'respond';\n            this._currentPriority = priority;\n            return;\n        }\n        if (priority === this._currentPriority) {\n            if (this._currentStrategy === 'abort') {\n                return;\n            }\n            this._currentStrategy = 'respond';\n        }\n    }\n    async _respond(response) {\n        this._interceptionHandled = true;\n        const responseBody = response.body && helper_js_1.helper.isString(response.body)\n            ? Buffer.from(response.body)\n            : response.body || null;\n        const responseHeaders = {};\n        if (response.headers) {\n            for (const header of Object.keys(response.headers))\n                responseHeaders[header.toLowerCase()] = String(response.headers[header]);\n        }\n        if (response.contentType)\n            responseHeaders['content-type'] = response.contentType;\n        if (responseBody && !('content-length' in responseHeaders))\n            responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n        await this._client\n            .send('Fetch.fulfillRequest', {\n            requestId: this._interceptionId,\n            responseCode: response.status || 200,\n            responsePhrase: STATUS_TEXTS[response.status || 200],\n            responseHeaders: headersArray(responseHeaders),\n            body: responseBody ? responseBody.toString('base64') : undefined,\n        })\n            .catch((error) => {\n            // In certain cases, protocol will return error if the request was\n            // already canceled or the page was closed. We should tolerate these\n            // errors.\n            helper_js_1.debugError(error);\n        });\n    }\n    /**\n     * Aborts a request.\n     *\n     * @remarks\n     * To use this, request interception should be enabled with\n     * {@link Page.setRequestInterception}. If it is not enabled, this method will\n     * throw an exception immediately.\n     *\n     * @param errorCode - optional error code to provide.\n     * @param priority - If provided, intercept is resolved using\n     * cooperative handling rules. Otherwise, intercept is resolved\n     * immediately.\n     */\n    async abort(errorCode = 'failed', priority) {\n        // Request interception is not supported for data: urls.\n        if (this._url.startsWith('data:'))\n            return;\n        const errorReason = errorReasons[errorCode];\n        assert_js_1.assert(errorReason, 'Unknown error code: ' + errorCode);\n        assert_js_1.assert(this._allowInterception, 'Request Interception is not enabled!');\n        assert_js_1.assert(!this._interceptionHandled, 'Request is already handled!');\n        if (priority === undefined) {\n            return this._abort(errorReason);\n        }\n        this._abortErrorReason = errorReason;\n        if (priority >= this._currentPriority ||\n            this._currentPriority === undefined) {\n            this._currentStrategy = 'abort';\n            this._currentPriority = priority;\n            return;\n        }\n    }\n    async _abort(errorReason) {\n        this._interceptionHandled = true;\n        await this._client\n            .send('Fetch.failRequest', {\n            requestId: this._interceptionId,\n            errorReason,\n        })\n            .catch((error) => {\n            // In certain cases, protocol will return error if the request was\n            // already canceled or the page was closed. We should tolerate these\n            // errors.\n            helper_js_1.debugError(error);\n        });\n    }\n}\nexports.HTTPRequest = HTTPRequest;\nconst errorReasons = {\n    aborted: 'Aborted',\n    accessdenied: 'AccessDenied',\n    addressunreachable: 'AddressUnreachable',\n    blockedbyclient: 'BlockedByClient',\n    blockedbyresponse: 'BlockedByResponse',\n    connectionaborted: 'ConnectionAborted',\n    connectionclosed: 'ConnectionClosed',\n    connectionfailed: 'ConnectionFailed',\n    connectionrefused: 'ConnectionRefused',\n    connectionreset: 'ConnectionReset',\n    internetdisconnected: 'InternetDisconnected',\n    namenotresolved: 'NameNotResolved',\n    timedout: 'TimedOut',\n    failed: 'Failed',\n};\nfunction headersArray(headers) {\n    const result = [];\n    for (const name in headers) {\n        if (!Object.is(headers[name], undefined))\n            result.push({ name, value: headers[name] + '' });\n    }\n    return result;\n}\n// List taken from\n// https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n// with extra 306 and 418 codes.\nconst STATUS_TEXTS = {\n    '100': 'Continue',\n    '101': 'Switching Protocols',\n    '102': 'Processing',\n    '103': 'Early Hints',\n    '200': 'OK',\n    '201': 'Created',\n    '202': 'Accepted',\n    '203': 'Non-Authoritative Information',\n    '204': 'No Content',\n    '205': 'Reset Content',\n    '206': 'Partial Content',\n    '207': 'Multi-Status',\n    '208': 'Already Reported',\n    '226': 'IM Used',\n    '300': 'Multiple Choices',\n    '301': 'Moved Permanently',\n    '302': 'Found',\n    '303': 'See Other',\n    '304': 'Not Modified',\n    '305': 'Use Proxy',\n    '306': 'Switch Proxy',\n    '307': 'Temporary Redirect',\n    '308': 'Permanent Redirect',\n    '400': 'Bad Request',\n    '401': 'Unauthorized',\n    '402': 'Payment Required',\n    '403': 'Forbidden',\n    '404': 'Not Found',\n    '405': 'Method Not Allowed',\n    '406': 'Not Acceptable',\n    '407': 'Proxy Authentication Required',\n    '408': 'Request Timeout',\n    '409': 'Conflict',\n    '410': 'Gone',\n    '411': 'Length Required',\n    '412': 'Precondition Failed',\n    '413': 'Payload Too Large',\n    '414': 'URI Too Long',\n    '415': 'Unsupported Media Type',\n    '416': 'Range Not Satisfiable',\n    '417': 'Expectation Failed',\n    '418': \"I'm a teapot\",\n    '421': 'Misdirected Request',\n    '422': 'Unprocessable Entity',\n    '423': 'Locked',\n    '424': 'Failed Dependency',\n    '425': 'Too Early',\n    '426': 'Upgrade Required',\n    '428': 'Precondition Required',\n    '429': 'Too Many Requests',\n    '431': 'Request Header Fields Too Large',\n    '451': 'Unavailable For Legal Reasons',\n    '500': 'Internal Server Error',\n    '501': 'Not Implemented',\n    '502': 'Bad Gateway',\n    '503': 'Service Unavailable',\n    '504': 'Gateway Timeout',\n    '505': 'HTTP Version Not Supported',\n    '506': 'Variant Also Negotiates',\n    '507': 'Insufficient Storage',\n    '508': 'Loop Detected',\n    '510': 'Not Extended',\n    '511': 'Network Authentication Required',\n};\n"]},"metadata":{},"sourceType":"script"}