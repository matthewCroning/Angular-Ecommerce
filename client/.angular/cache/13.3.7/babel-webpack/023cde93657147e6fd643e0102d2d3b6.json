{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Matth\\\\workspace\\\\angular-ecommerce\\\\client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebWorker = void 0;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\n\nconst helper_js_1 = require(\"./helper.js\");\n\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\n\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\n/**\n * The WebWorker class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n * ```js\n * page.on('workercreated', worker => console.log('Worker created: ' + worker.url()));\n * page.on('workerdestroyed', worker => console.log('Worker destroyed: ' + worker.url()));\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\n\n\nclass WebWorker extends EventEmitter_js_1.EventEmitter {\n  /**\n   *\n   * @internal\n   */\n  constructor(client, url, consoleAPICalled, exceptionThrown) {\n    var _this;\n\n    super();\n    _this = this;\n    this._client = client;\n    this._url = url;\n    this._executionContextPromise = new Promise(x => this._executionContextCallback = x);\n    let jsHandleFactory;\n\n    this._client.once('Runtime.executionContextCreated', /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (event) {\n        // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n        jsHandleFactory = remoteObject => new JSHandle_js_1.JSHandle(executionContext, client, remoteObject);\n\n        const executionContext = new ExecutionContext_js_1.ExecutionContext(client, event.context, null);\n\n        _this._executionContextCallback(executionContext);\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()); // This might fail if the target is closed before we receive all execution contexts.\n\n\n    this._client.send('Runtime.enable').catch(helper_js_1.debugError);\n\n    this._client.on('Runtime.consoleAPICalled', event => consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace));\n\n    this._client.on('Runtime.exceptionThrown', exception => exceptionThrown(exception.exceptionDetails));\n  }\n  /**\n   * @returns The URL of this web worker.\n   */\n\n\n  url() {\n    return this._url;\n  }\n  /**\n   * Returns the ExecutionContext the WebWorker runs in\n   * @returns The ExecutionContext the web worker runs in.\n   */\n\n\n  executionContext() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2._executionContextPromise;\n    })();\n  }\n  /**\n   * If the function passed to the `worker.evaluate` returns a Promise, then\n   * `worker.evaluate` would wait for the promise to resolve and return its\n   * value. If the function passed to the `worker.evaluate` returns a\n   * non-serializable value, then `worker.evaluate` resolves to `undefined`.\n   * DevTools Protocol also supports transferring some additional values that\n   * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and\n   * bigint literals.\n   * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.\n   *\n   * @param pageFunction - Function to be evaluated in the worker context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n\n\n  evaluate(pageFunction, ...args) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this3._executionContextPromise).evaluate(pageFunction, ...args);\n    })();\n  }\n  /**\n   * The only difference between `worker.evaluate` and `worker.evaluateHandle`\n   * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the\n   * function passed to the `worker.evaluateHandle` returns a `Promise`, then\n   * `worker.evaluateHandle` would wait for the promise to resolve and return\n   * its value. Shortcut for\n   * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`\n   *\n   * @param pageFunction - Function to be evaluated in the page context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n\n\n  evaluateHandle(pageFunction, ...args) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      return (yield _this4._executionContextPromise).evaluateHandle(pageFunction, ...args);\n    })();\n  }\n\n}\n\nexports.WebWorker = WebWorker;","map":{"version":3,"sources":["C:/Users/Matth/workspace/node_modules/puppeteer/lib/cjs/puppeteer/common/WebWorker.js"],"names":["Object","defineProperty","exports","value","WebWorker","EventEmitter_js_1","require","helper_js_1","ExecutionContext_js_1","JSHandle_js_1","EventEmitter","constructor","client","url","consoleAPICalled","exceptionThrown","_client","_url","_executionContextPromise","Promise","x","_executionContextCallback","jsHandleFactory","once","event","remoteObject","JSHandle","executionContext","ExecutionContext","context","send","catch","debugError","on","type","args","map","stackTrace","exception","exceptionDetails","evaluate","pageFunction","evaluateHandle"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebWorker = void 0;\n/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst EventEmitter_js_1 = require(\"./EventEmitter.js\");\nconst helper_js_1 = require(\"./helper.js\");\nconst ExecutionContext_js_1 = require(\"./ExecutionContext.js\");\nconst JSHandle_js_1 = require(\"./JSHandle.js\");\n/**\n * The WebWorker class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n * ```js\n * page.on('workercreated', worker => console.log('Worker created: ' + worker.url()));\n * page.on('workerdestroyed', worker => console.log('Worker destroyed: ' + worker.url()));\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nclass WebWorker extends EventEmitter_js_1.EventEmitter {\n    /**\n     *\n     * @internal\n     */\n    constructor(client, url, consoleAPICalled, exceptionThrown) {\n        super();\n        this._client = client;\n        this._url = url;\n        this._executionContextPromise = new Promise((x) => (this._executionContextCallback = x));\n        let jsHandleFactory;\n        this._client.once('Runtime.executionContextCreated', async (event) => {\n            // eslint-disable-next-line @typescript-eslint/explicit-function-return-type\n            jsHandleFactory = (remoteObject) => new JSHandle_js_1.JSHandle(executionContext, client, remoteObject);\n            const executionContext = new ExecutionContext_js_1.ExecutionContext(client, event.context, null);\n            this._executionContextCallback(executionContext);\n        });\n        // This might fail if the target is closed before we receive all execution contexts.\n        this._client.send('Runtime.enable').catch(helper_js_1.debugError);\n        this._client.on('Runtime.consoleAPICalled', (event) => consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace));\n        this._client.on('Runtime.exceptionThrown', (exception) => exceptionThrown(exception.exceptionDetails));\n    }\n    /**\n     * @returns The URL of this web worker.\n     */\n    url() {\n        return this._url;\n    }\n    /**\n     * Returns the ExecutionContext the WebWorker runs in\n     * @returns The ExecutionContext the web worker runs in.\n     */\n    async executionContext() {\n        return this._executionContextPromise;\n    }\n    /**\n     * If the function passed to the `worker.evaluate` returns a Promise, then\n     * `worker.evaluate` would wait for the promise to resolve and return its\n     * value. If the function passed to the `worker.evaluate` returns a\n     * non-serializable value, then `worker.evaluate` resolves to `undefined`.\n     * DevTools Protocol also supports transferring some additional values that\n     * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and\n     * bigint literals.\n     * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.\n     *\n     * @param pageFunction - Function to be evaluated in the worker context.\n     * @param args - Arguments to pass to `pageFunction`.\n     * @returns Promise which resolves to the return value of `pageFunction`.\n     */\n    async evaluate(pageFunction, ...args) {\n        return (await this._executionContextPromise).evaluate(pageFunction, ...args);\n    }\n    /**\n     * The only difference between `worker.evaluate` and `worker.evaluateHandle`\n     * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the\n     * function passed to the `worker.evaluateHandle` returns a `Promise`, then\n     * `worker.evaluateHandle` would wait for the promise to resolve and return\n     * its value. Shortcut for\n     * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`\n     *\n     * @param pageFunction - Function to be evaluated in the page context.\n     * @param args - Arguments to pass to `pageFunction`.\n     * @returns Promise which resolves to the return value of `pageFunction`.\n     */\n    async evaluateHandle(pageFunction, ...args) {\n        return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);\n    }\n}\nexports.WebWorker = WebWorker;\n"]},"metadata":{},"sourceType":"script"}