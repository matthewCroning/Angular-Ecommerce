{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Matth\\\\workspace\\\\angular-ecommerce\\\\client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst {\n  constants: BufferConstants\n} = require('buffer');\n\nconst pump = require('pump');\n\nconst bufferStream = require('./buffer-stream');\n\nclass MaxBufferError extends Error {\n  constructor() {\n    super('maxBuffer exceeded');\n    this.name = 'MaxBufferError';\n  }\n\n}\n\nfunction getStream(_x, _x2) {\n  return _getStream.apply(this, arguments);\n}\n\nfunction _getStream() {\n  _getStream = _asyncToGenerator(function* (inputStream, options) {\n    if (!inputStream) {\n      return Promise.reject(new Error('Expected a stream'));\n    }\n\n    options = {\n      maxBuffer: Infinity,\n      ...options\n    };\n    const {\n      maxBuffer\n    } = options;\n    let stream;\n    yield new Promise((resolve, reject) => {\n      const rejectPromise = error => {\n        // Don't retrieve an oversized buffer.\n        if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n          error.bufferedData = stream.getBufferedValue();\n        }\n\n        reject(error);\n      };\n\n      stream = pump(inputStream, bufferStream(options), error => {\n        if (error) {\n          rejectPromise(error);\n          return;\n        }\n\n        resolve();\n      });\n      stream.on('data', () => {\n        if (stream.getBufferedLength() > maxBuffer) {\n          rejectPromise(new MaxBufferError());\n        }\n      });\n    });\n    return stream.getBufferedValue();\n  });\n  return _getStream.apply(this, arguments);\n}\n\nmodule.exports = getStream; // TODO: Remove this for the next major release\n\nmodule.exports.default = getStream;\n\nmodule.exports.buffer = (stream, options) => getStream(stream, { ...options,\n  encoding: 'buffer'\n});\n\nmodule.exports.array = (stream, options) => getStream(stream, { ...options,\n  array: true\n});\n\nmodule.exports.MaxBufferError = MaxBufferError;","map":{"version":3,"sources":["C:/Users/Matth/workspace/node_modules/extract-zip/node_modules/get-stream/index.js"],"names":["constants","BufferConstants","require","pump","bufferStream","MaxBufferError","Error","constructor","name","getStream","inputStream","options","Promise","reject","maxBuffer","Infinity","stream","resolve","rejectPromise","error","getBufferedLength","MAX_LENGTH","bufferedData","getBufferedValue","on","module","exports","default","buffer","encoding","array"],"mappings":"AAAA;;;;AACA,MAAM;AAACA,EAAAA,SAAS,EAAEC;AAAZ,IAA+BC,OAAO,CAAC,QAAD,CAA5C;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA5B;;AAEA,MAAMG,cAAN,SAA6BC,KAA7B,CAAmC;AAClCC,EAAAA,WAAW,GAAG;AACb,UAAM,oBAAN;AACA,SAAKC,IAAL,GAAY,gBAAZ;AACA;;AAJiC;;SAOpBC,S;;;;;iCAAf,WAAyBC,WAAzB,EAAsCC,OAAtC,EAA+C;AAC9C,QAAI,CAACD,WAAL,EAAkB;AACjB,aAAOE,OAAO,CAACC,MAAR,CAAe,IAAIP,KAAJ,CAAU,mBAAV,CAAf,CAAP;AACA;;AAEDK,IAAAA,OAAO,GAAG;AACTG,MAAAA,SAAS,EAAEC,QADF;AAET,SAAGJ;AAFM,KAAV;AAKA,UAAM;AAACG,MAAAA;AAAD,QAAcH,OAApB;AAEA,QAAIK,MAAJ;AACA,UAAM,IAAIJ,OAAJ,CAAY,CAACK,OAAD,EAAUJ,MAAV,KAAqB;AACtC,YAAMK,aAAa,GAAGC,KAAK,IAAI;AAC9B;AACA,YAAIA,KAAK,IAAIH,MAAM,CAACI,iBAAP,MAA8BnB,eAAe,CAACoB,UAA3D,EAAuE;AACtEF,UAAAA,KAAK,CAACG,YAAN,GAAqBN,MAAM,CAACO,gBAAP,EAArB;AACA;;AAEDV,QAAAA,MAAM,CAACM,KAAD,CAAN;AACA,OAPD;;AASAH,MAAAA,MAAM,GAAGb,IAAI,CAACO,WAAD,EAAcN,YAAY,CAACO,OAAD,CAA1B,EAAqCQ,KAAK,IAAI;AAC1D,YAAIA,KAAJ,EAAW;AACVD,UAAAA,aAAa,CAACC,KAAD,CAAb;AACA;AACA;;AAEDF,QAAAA,OAAO;AACP,OAPY,CAAb;AASAD,MAAAA,MAAM,CAACQ,EAAP,CAAU,MAAV,EAAkB,MAAM;AACvB,YAAIR,MAAM,CAACI,iBAAP,KAA6BN,SAAjC,EAA4C;AAC3CI,UAAAA,aAAa,CAAC,IAAIb,cAAJ,EAAD,CAAb;AACA;AACD,OAJD;AAKA,KAxBK,CAAN;AA0BA,WAAOW,MAAM,CAACO,gBAAP,EAAP;AACA,G;;;;AAEDE,MAAM,CAACC,OAAP,GAAiBjB,SAAjB,C,CACA;;AACAgB,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyBlB,SAAzB;;AACAgB,MAAM,CAACC,OAAP,CAAeE,MAAf,GAAwB,CAACZ,MAAD,EAASL,OAAT,KAAqBF,SAAS,CAACO,MAAD,EAAS,EAAC,GAAGL,OAAJ;AAAakB,EAAAA,QAAQ,EAAE;AAAvB,CAAT,CAAtD;;AACAJ,MAAM,CAACC,OAAP,CAAeI,KAAf,GAAuB,CAACd,MAAD,EAASL,OAAT,KAAqBF,SAAS,CAACO,MAAD,EAAS,EAAC,GAAGL,OAAJ;AAAamB,EAAAA,KAAK,EAAE;AAApB,CAAT,CAArD;;AACAL,MAAM,CAACC,OAAP,CAAerB,cAAf,GAAgCA,cAAhC","sourcesContent":["'use strict';\nconst {constants: BufferConstants} = require('buffer');\nconst pump = require('pump');\nconst bufferStream = require('./buffer-stream');\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\treturn Promise.reject(new Error('Expected a stream'));\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\n\tlet stream;\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\t// Don't retrieve an oversized buffer.\n\t\t\tif (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\tstream = pump(inputStream, bufferStream(options), error => {\n\t\t\tif (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve();\n\t\t});\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\n// TODO: Remove this for the next major release\nmodule.exports.default = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n"]},"metadata":{},"sourceType":"script"}