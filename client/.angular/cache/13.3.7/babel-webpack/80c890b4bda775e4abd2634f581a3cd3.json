{"ast":null,"code":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\nvar _require2 = require('../experimentalWarning'),\n    emitExperimentalWarning = _require2.emitExperimentalWarning; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\n\nrequire('inherits')(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc); // if setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding;\n  return this;\n}; // Don't raise the hwm > 8MB\n\n\nvar MAX_HWM = 0x800000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  this.emit('error', new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    emitExperimentalWarning('Readable[Symbol.asyncIterator]');\n\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","map":{"version":3,"sources":["C:/Users/Matth/workspace/node_modules/readable-stream/lib/_stream_readable.js"],"names":["module","exports","Readable","Duplex","ReadableState","EE","require","EventEmitter","EElistenerCount","emitter","type","listeners","length","Stream","Buffer","OurUint8Array","global","Uint8Array","_uint8ArrayToBuffer","chunk","from","_isUint8Array","obj","isBuffer","debugUtil","debug","debuglog","BufferList","destroyImpl","_require","getHighWaterMark","_require$codes","codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PUSH_AFTER_EOF","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","_require2","emitExperimentalWarning","StringDecoder","createReadableStreamAsyncIterator","kProxyEvents","prependListener","event","fn","_events","on","Array","isArray","unshift","options","stream","isDuplex","objectMode","readableObjectMode","highWaterMark","buffer","pipes","pipesCount","flowing","ended","endEmitted","reading","sync","needReadable","emittedReadable","readableListening","resumeScheduled","paused","emitClose","destroyed","defaultEncoding","awaitDrain","readingMore","decoder","encoding","_readableState","readable","read","_read","destroy","_destroy","call","Object","defineProperty","prototype","enumerable","get","undefined","set","value","_undestroy","undestroy","err","cb","push","state","skipChunkCheck","readableAddChunk","addToFront","onEofChunk","er","chunkInvalid","emit","getPrototypeOf","addChunk","write","maybeReadMore","emitReadable","isPaused","setEncoding","enc","MAX_HWM","computeNewHighWaterMark","n","howMuchToRead","head","data","parseInt","nOrig","endReadable","doRead","ret","fromList","end","emitReadable_","process","nextTick","flow","maybeReadMore_","len","pipe","dest","pipeOpts","src","doEnd","stdout","stderr","endFn","onend","unpipe","once","onunpipe","unpipeInfo","hasUnpiped","cleanup","ondrain","pipeOnDrain","cleanedUp","removeListener","onclose","onfinish","onerror","ondata","_writableState","needDrain","indexOf","pause","resume","pipeOnDrainFunctionResult","dests","i","index","splice","ev","res","listenerCount","nReadingNextTick","addListener","updateReadableListening","removeAllListeners","apply","arguments","self","resume_","wrap","_this","methodWrap","method","methodWrapReturnFunction","bind","Symbol","asyncIterator","_fromList","shift","join","first","concat","clear","consume","endReadableNT","xs","x","l"],"mappings":"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","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\nvar _require2 = require('../experimentalWarning'),\n    emitExperimentalWarning = _require2.emitExperimentalWarning; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\n\nrequire('inherits')(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc); // if setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding;\n  return this;\n}; // Don't raise the hwm > 8MB\n\n\nvar MAX_HWM = 0x800000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  this.emit('error', new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    emitExperimentalWarning('Readable[Symbol.asyncIterator]');\n\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}"]},"metadata":{},"sourceType":"script"}