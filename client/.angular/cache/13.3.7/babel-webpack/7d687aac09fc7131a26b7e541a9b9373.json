{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { of, fromEvent } from 'rxjs';\nimport { mergeMap, map, tap, filter, throttleTime } from 'rxjs/operators';\n\nclass NgxInfiniteScrollService {\n  constructor() {}\n\n}\n\nNgxInfiniteScrollService.ɵfac = function NgxInfiniteScrollService_Factory(t) {\n  return new (t || NgxInfiniteScrollService)();\n};\n\nNgxInfiniteScrollService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxInfiniteScrollService,\n  factory: NgxInfiniteScrollService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxInfiniteScrollService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [];\n  }, null);\n})();\n\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n  const hasWindow = window && !!window.document && window.document.documentElement;\n  let container = hasWindow && scrollWindow ? window : defaultElement;\n\n  if (selector) {\n    const containerIsString = selector && hasWindow && typeof selector === 'string';\n    container = containerIsString ? findElement(selector, defaultElement.nativeElement, fromRoot) : selector;\n\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n\n  return container;\n}\n\nfunction findElement(selector, customRoot, fromRoot) {\n  const rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n\nfunction inputPropChanged(prop) {\n  return prop && !prop.firstChange;\n}\n\nfunction hasWindowDefined() {\n  return typeof window !== 'undefined';\n}\n\nconst VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\nconst HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\n\nclass AxisResolver {\n  constructor(vertical = true) {\n    this.vertical = vertical;\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n\n  clientHeightKey() {\n    return this.propsMap.clientHeight;\n  }\n\n  offsetHeightKey() {\n    return this.propsMap.offsetHeight;\n  }\n\n  scrollHeightKey() {\n    return this.propsMap.scrollHeight;\n  }\n\n  pageYOffsetKey() {\n    return this.propsMap.pageYOffset;\n  }\n\n  offsetTopKey() {\n    return this.propsMap.offsetTop;\n  }\n\n  scrollTopKey() {\n    return this.propsMap.scrollTop;\n  }\n\n  topKey() {\n    return this.propsMap.top;\n  }\n\n}\n\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createResolver({\n  windowElement,\n  axis\n}) {\n  return createResolverWithContainer({\n    axis,\n    isWindow: isElementWindow(windowElement)\n  }, windowElement);\n}\n\nfunction createResolverWithContainer(resolver, windowElement) {\n  const container = resolver.isWindow || windowElement && !windowElement.nativeElement ? windowElement : windowElement.nativeElement;\n  return Object.assign(Object.assign({}, resolver), {\n    container\n  });\n}\n\nfunction isElementWindow(windowElement) {\n  const isWindow = ['Window', 'global'].some(obj => Object.prototype.toString.call(windowElement).includes(obj));\n  return isWindow;\n}\n\nfunction getDocumentElement(isContainerWindow, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n\nfunction calculatePoints(element, resolver) {\n  const height = extractHeightForElement(resolver);\n  return resolver.isWindow ? calculatePointsForWindow(height, element, resolver) : calculatePointsForElement(height, element, resolver);\n}\n\nfunction calculatePointsForWindow(height, element, resolver) {\n  const {\n    axis,\n    container,\n    isWindow\n  } = resolver;\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis); // scrolled until now / current y point\n\n  const scrolled = height + getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow); // total height / most bottom y point\n\n  const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n  const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) + nativeElementHeight;\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow\n  };\n}\n\nfunction calculatePointsForElement(height, element, resolver) {\n  const {\n    axis,\n    container\n  } = resolver; // perhaps use container.offsetTop instead of 'scrollTop'\n\n  const scrolled = container[axis.scrollTopKey()];\n  const totalToScroll = container[axis.scrollHeightKey()];\n  return {\n    height,\n    scrolled,\n    totalToScroll,\n    isWindow: false\n  };\n}\n\nfunction extractHeightPropKeys(axis) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n\nfunction extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}) {\n  const {\n    offsetHeightKey,\n    clientHeightKey\n  } = extractHeightPropKeys(axis);\n  return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\n\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n  if (isNaN(elem[offsetHeightKey])) {\n    const docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n\nfunction getElementOffsetTop(elem, axis, isWindow) {\n  const topKey = axis.topKey(); // elem = elem.nativeElement;\n\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n\n  return elem.getBoundingClientRect()[topKey] + getElementPageYOffset(elem, axis, isWindow);\n}\n\nfunction getElementPageYOffset(elem, axis, isWindow) {\n  const pageYOffset = axis.pageYOffsetKey();\n  const scrollTop = axis.scrollTopKey();\n  const offsetTop = axis.offsetTopKey();\n\n  if (isNaN(window.pageYOffset)) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n\nfunction shouldFireScrollEvent(container, distance = {\n  down: 0,\n  up: 0\n}, scrollingDown) {\n  let remaining;\n  let containerBreakpoint;\n\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n\n  const scrolledUntilNow = container.isWindow ? container.scrolled : container.height + container.scrolled;\n\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    const distanceDown = (distance === null || distance === void 0 ? void 0 : distance.down) ? distance.down : 0;\n    containerBreakpoint = distanceDown / 10;\n  } else {\n    const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    const distanceUp = (distance === null || distance === void 0 ? void 0 : distance.up) ? distance.up : 0;\n    containerBreakpoint = distanceUp / 10;\n  }\n\n  const shouldFireEvent = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n\nfunction isScrollingDownwards(lastScrollPosition, container) {\n  return lastScrollPosition < container.scrolled;\n}\n\nfunction getScrollStats(lastScrollPosition, container, distance) {\n  const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown\n  };\n}\n\nfunction updateScrollPosition(position, scrollState) {\n  return scrollState.lastScrollPosition = position;\n}\n\nfunction updateTotalToScroll(totalToScroll, scrollState) {\n  if (scrollState.lastTotalToScroll !== totalToScroll) {\n    scrollState.lastTotalToScroll = scrollState.totalToScroll;\n    scrollState.totalToScroll = totalToScroll;\n  }\n}\n\nfunction isSameTotalToScroll(scrollState) {\n  return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\n\nfunction updateTriggeredFlag(scroll, scrollState, triggered, isScrollingDown) {\n  if (isScrollingDown) {\n    scrollState.triggered.down = scroll;\n  } else {\n    scrollState.triggered.up = scroll;\n  }\n}\n\nfunction isTriggeredScroll(totalToScroll, scrollState, isScrollingDown) {\n  return isScrollingDown ? scrollState.triggered.down === totalToScroll : scrollState.triggered.up === totalToScroll;\n}\n\nfunction updateScrollState(scrollState, scrolledUntilNow, totalToScroll) {\n  updateScrollPosition(scrolledUntilNow, scrollState);\n  updateTotalToScroll(totalToScroll, scrollState); // const isSameTotal = isSameTotalToScroll(scrollState);\n  // if (!isSameTotal) {\n  //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n  // }\n}\n\nclass ScrollState {\n  constructor({\n    totalToScroll\n  }) {\n    this.lastScrollPosition = 0;\n    this.lastTotalToScroll = 0;\n    this.totalToScroll = 0;\n    this.triggered = {\n      down: 0,\n      up: 0\n    };\n    this.totalToScroll = totalToScroll;\n  }\n\n  updateScrollPosition(position) {\n    return this.lastScrollPosition = position;\n  }\n\n  updateTotalToScroll(totalToScroll) {\n    if (this.lastTotalToScroll !== totalToScroll) {\n      this.lastTotalToScroll = this.totalToScroll;\n      this.totalToScroll = totalToScroll;\n    }\n  }\n\n  updateScroll(scrolledUntilNow, totalToScroll) {\n    this.updateScrollPosition(scrolledUntilNow);\n    this.updateTotalToScroll(totalToScroll);\n  }\n\n  updateTriggeredFlag(scroll, isScrollingDown) {\n    if (isScrollingDown) {\n      this.triggered.down = scroll;\n    } else {\n      this.triggered.up = scroll;\n    }\n  }\n\n  isTriggeredScroll(totalToScroll, isScrollingDown) {\n    return isScrollingDown ? this.triggered.down === totalToScroll : this.triggered.up === totalToScroll;\n  }\n\n}\n\nfunction createScroller(config) {\n  const {\n    scrollContainer,\n    scrollWindow,\n    element,\n    fromRoot\n  } = config;\n  const resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  const scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver)\n  });\n  const options = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  const distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map(positionStats => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({\n    stats\n  }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({\n    fire,\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({\n    scrollDown,\n    stats: {\n      totalToScroll\n    }\n  }) => {\n    scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n  }), map(toInfiniteScrollAction));\n}\n\nfunction attachScrollEvent(options) {\n  let obs = fromEvent(options.container, 'scroll'); // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // Replacing with throttleTime seems to solve the problem\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n\n  if (options.throttle) {\n    obs = obs.pipe(throttleTime(options.throttle, undefined, {\n      leading: true,\n      trailing: true\n    }));\n  }\n\n  return obs;\n}\n\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n  const {\n    scrollDown,\n    fire\n  } = getScrollStats(lastScrollPosition, stats, distance);\n  return {\n    scrollDown,\n    fire,\n    stats\n  };\n}\n\nconst InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\n\nfunction toInfiniteScrollAction(response) {\n  const {\n    scrollDown,\n    stats: {\n      scrolled: currentScrollPosition\n    }\n  } = response;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition\n    }\n  };\n}\n\nclass InfiniteScrollDirective {\n  constructor(element, zone) {\n    this.element = element;\n    this.zone = zone;\n    this.scrolled = new EventEmitter();\n    this.scrolledUp = new EventEmitter();\n    this.infiniteScrollDistance = 2;\n    this.infiniteScrollUpDistance = 1.5;\n    this.infiniteScrollThrottle = 150;\n    this.infiniteScrollDisabled = false;\n    this.infiniteScrollContainer = null;\n    this.scrollWindow = true;\n    this.immediateCheck = false;\n    this.horizontal = false;\n    this.alwaysCallback = false;\n    this.fromRoot = false;\n  }\n\n  ngAfterViewInit() {\n    if (!this.infiniteScrollDisabled) {\n      this.setup();\n    }\n  }\n\n  ngOnChanges({\n    infiniteScrollContainer,\n    infiniteScrollDisabled,\n    infiniteScrollDistance\n  }) {\n    const containerChanged = inputPropChanged(infiniteScrollContainer);\n    const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n    const distanceChanged = inputPropChanged(infiniteScrollDistance);\n    const shouldSetup = !disabledChanged && !this.infiniteScrollDisabled || disabledChanged && !infiniteScrollDisabled.currentValue || distanceChanged;\n\n    if (containerChanged || disabledChanged || distanceChanged) {\n      this.destroyScroller();\n\n      if (shouldSetup) {\n        this.setup();\n      }\n    }\n  }\n\n  setup() {\n    if (hasWindowDefined()) {\n      this.zone.runOutsideAngular(() => {\n        this.disposeScroller = createScroller({\n          fromRoot: this.fromRoot,\n          alwaysCallback: this.alwaysCallback,\n          disable: this.infiniteScrollDisabled,\n          downDistance: this.infiniteScrollDistance,\n          element: this.element,\n          horizontal: this.horizontal,\n          scrollContainer: this.infiniteScrollContainer,\n          scrollWindow: this.scrollWindow,\n          throttle: this.infiniteScrollThrottle,\n          upDistance: this.infiniteScrollUpDistance\n        }).subscribe(payload => this.zone.run(() => this.handleOnScroll(payload)));\n      });\n    }\n  }\n\n  handleOnScroll({\n    type,\n    payload\n  }) {\n    switch (type) {\n      case InfiniteScrollActions.DOWN:\n        return this.scrolled.emit(payload);\n\n      case InfiniteScrollActions.UP:\n        return this.scrolledUp.emit(payload);\n\n      default:\n        return;\n    }\n  }\n\n  ngOnDestroy() {\n    this.destroyScroller();\n  }\n\n  destroyScroller() {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\n\n}\n\nInfiniteScrollDirective.ɵfac = function InfiniteScrollDirective_Factory(t) {\n  return new (t || InfiniteScrollDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nInfiniteScrollDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: InfiniteScrollDirective,\n  selectors: [[\"\", \"infiniteScroll\", \"\"], [\"\", \"infinite-scroll\", \"\"], [\"\", \"data-infinite-scroll\", \"\"]],\n  inputs: {\n    infiniteScrollDistance: \"infiniteScrollDistance\",\n    infiniteScrollUpDistance: \"infiniteScrollUpDistance\",\n    infiniteScrollThrottle: \"infiniteScrollThrottle\",\n    infiniteScrollDisabled: \"infiniteScrollDisabled\",\n    infiniteScrollContainer: \"infiniteScrollContainer\",\n    scrollWindow: \"scrollWindow\",\n    immediateCheck: \"immediateCheck\",\n    horizontal: \"horizontal\",\n    alwaysCallback: \"alwaysCallback\",\n    fromRoot: \"fromRoot\"\n  },\n  outputs: {\n    scrolled: \"scrolled\",\n    scrolledUp: \"scrolledUp\"\n  },\n  features: [i0.ɵɵNgOnChangesFeature]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InfiniteScrollDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    scrolled: [{\n      type: Output\n    }],\n    scrolledUp: [{\n      type: Output\n    }],\n    infiniteScrollDistance: [{\n      type: Input\n    }],\n    infiniteScrollUpDistance: [{\n      type: Input\n    }],\n    infiniteScrollThrottle: [{\n      type: Input\n    }],\n    infiniteScrollDisabled: [{\n      type: Input\n    }],\n    infiniteScrollContainer: [{\n      type: Input\n    }],\n    scrollWindow: [{\n      type: Input\n    }],\n    immediateCheck: [{\n      type: Input\n    }],\n    horizontal: [{\n      type: Input\n    }],\n    alwaysCallback: [{\n      type: Input\n    }],\n    fromRoot: [{\n      type: Input\n    }]\n  });\n})();\n\nclass InfiniteScrollModule {}\n\nInfiniteScrollModule.ɵfac = function InfiniteScrollModule_Factory(t) {\n  return new (t || InfiniteScrollModule)();\n};\n\nInfiniteScrollModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: InfiniteScrollModule\n});\nInfiniteScrollModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [],\n  imports: [[]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InfiniteScrollModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [InfiniteScrollDirective],\n      exports: [InfiniteScrollDirective],\n      imports: [],\n      providers: []\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of ngx-infinite-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { InfiniteScrollDirective, InfiniteScrollModule, NgxInfiniteScrollService };","map":{"version":3,"sources":["C:/Users/Matth/workspace/angular-ecommerce/client/node_modules/ngx-infinite-scroll/fesm2015/ngx-infinite-scroll.mjs"],"names":["i0","Injectable","EventEmitter","Directive","Output","Input","NgModule","of","fromEvent","mergeMap","map","tap","filter","throttleTime","NgxInfiniteScrollService","constructor","ɵfac","ɵprov","type","args","providedIn","resolveContainerElement","selector","scrollWindow","defaultElement","fromRoot","hasWindow","window","document","documentElement","container","containerIsString","findElement","nativeElement","Error","customRoot","rootEl","querySelector","inputPropChanged","prop","firstChange","hasWindowDefined","VerticalProps","clientHeight","offsetHeight","scrollHeight","pageYOffset","offsetTop","scrollTop","top","HorizontalProps","AxisResolver","vertical","propsMap","clientHeightKey","offsetHeightKey","scrollHeightKey","pageYOffsetKey","offsetTopKey","scrollTopKey","topKey","shouldTriggerEvents","alwaysCallback","shouldFireScrollEvent","isTriggeredCurrentTotal","createResolver","windowElement","axis","createResolverWithContainer","isWindow","isElementWindow","resolver","Object","assign","some","obj","prototype","toString","call","includes","getDocumentElement","isContainerWindow","calculatePoints","element","height","extractHeightForElement","calculatePointsForWindow","calculatePointsForElement","extractHeightPropKeys","scrolled","getElementPageYOffset","nativeElementHeight","getElementHeight","totalToScroll","getElementOffsetTop","elem","isNaN","docElem","getBoundingClientRect","ownerDocument","defaultView","distance","down","up","scrollingDown","remaining","containerBreakpoint","scrolledUntilNow","distanceDown","totalHiddenContentHeight","distanceUp","shouldFireEvent","isScrollingDownwards","lastScrollPosition","getScrollStats","scrollDown","fire","updateScrollPosition","position","scrollState","updateTotalToScroll","lastTotalToScroll","isSameTotalToScroll","updateTriggeredFlag","scroll","triggered","isScrollingDown","isTriggeredScroll","updateScrollState","ScrollState","updateScroll","createScroller","config","scrollContainer","horizontal","options","throttle","upDistance","downDistance","attachScrollEvent","pipe","positionStats","toInfiniteScrollParams","stats","toInfiniteScrollAction","obs","undefined","leading","trailing","InfiniteScrollActions","DOWN","UP","response","currentScrollPosition","payload","InfiniteScrollDirective","zone","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","immediateCheck","ngAfterViewInit","setup","ngOnChanges","containerChanged","disabledChanged","distanceChanged","shouldSetup","currentValue","destroyScroller","runOutsideAngular","disposeScroller","disable","subscribe","run","handleOnScroll","emit","ngOnDestroy","unsubscribe","ElementRef","NgZone","ɵdir","InfiniteScrollModule","ɵmod","ɵinj","declarations","exports","imports","providers"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { of, fromEvent } from 'rxjs';\nimport { mergeMap, map, tap, filter, throttleTime } from 'rxjs/operators';\n\nclass NgxInfiniteScrollService {\n    constructor() { }\n}\nNgxInfiniteScrollService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.3\", ngImport: i0, type: NgxInfiniteScrollService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNgxInfiniteScrollService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.3\", ngImport: i0, type: NgxInfiniteScrollService, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.3\", ngImport: i0, type: NgxInfiniteScrollService, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }], ctorParameters: function () { return []; } });\n\nfunction resolveContainerElement(selector, scrollWindow, defaultElement, fromRoot) {\n    const hasWindow = window && !!window.document && window.document.documentElement;\n    let container = hasWindow && scrollWindow ? window : defaultElement;\n    if (selector) {\n        const containerIsString = selector && hasWindow && typeof selector === 'string';\n        container = containerIsString\n            ? findElement(selector, defaultElement.nativeElement, fromRoot)\n            : selector;\n        if (!container) {\n            throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n        }\n    }\n    return container;\n}\nfunction findElement(selector, customRoot, fromRoot) {\n    const rootEl = fromRoot ? window.document : customRoot;\n    return rootEl.querySelector(selector);\n}\nfunction inputPropChanged(prop) {\n    return prop && !prop.firstChange;\n}\nfunction hasWindowDefined() {\n    return typeof window !== 'undefined';\n}\n\nconst VerticalProps = {\n    clientHeight: \"clientHeight\",\n    offsetHeight: \"offsetHeight\",\n    scrollHeight: \"scrollHeight\",\n    pageYOffset: \"pageYOffset\",\n    offsetTop: \"offsetTop\",\n    scrollTop: \"scrollTop\",\n    top: \"top\"\n};\nconst HorizontalProps = {\n    clientHeight: \"clientWidth\",\n    offsetHeight: \"offsetWidth\",\n    scrollHeight: \"scrollWidth\",\n    pageYOffset: \"pageXOffset\",\n    offsetTop: \"offsetLeft\",\n    scrollTop: \"scrollLeft\",\n    top: \"left\"\n};\nclass AxisResolver {\n    constructor(vertical = true) {\n        this.vertical = vertical;\n        this.propsMap = vertical ? VerticalProps : HorizontalProps;\n    }\n    clientHeightKey() {\n        return this.propsMap.clientHeight;\n    }\n    offsetHeightKey() {\n        return this.propsMap.offsetHeight;\n    }\n    scrollHeightKey() {\n        return this.propsMap.scrollHeight;\n    }\n    pageYOffsetKey() {\n        return this.propsMap.pageYOffset;\n    }\n    offsetTopKey() {\n        return this.propsMap.offsetTop;\n    }\n    scrollTopKey() {\n        return this.propsMap.scrollTop;\n    }\n    topKey() {\n        return this.propsMap.top;\n    }\n}\n\nfunction shouldTriggerEvents(alwaysCallback, shouldFireScrollEvent, isTriggeredCurrentTotal) {\n    if (alwaysCallback && shouldFireScrollEvent) {\n        return true;\n    }\n    if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n        return true;\n    }\n    return false;\n}\n\nfunction createResolver({ windowElement, axis, }) {\n    return createResolverWithContainer({ axis, isWindow: isElementWindow(windowElement) }, windowElement);\n}\nfunction createResolverWithContainer(resolver, windowElement) {\n    const container = resolver.isWindow || (windowElement && !windowElement.nativeElement)\n        ? windowElement\n        : windowElement.nativeElement;\n    return Object.assign(Object.assign({}, resolver), { container });\n}\nfunction isElementWindow(windowElement) {\n    const isWindow = ['Window', 'global'].some((obj) => Object.prototype.toString.call(windowElement).includes(obj));\n    return isWindow;\n}\nfunction getDocumentElement(isContainerWindow, windowElement) {\n    return isContainerWindow ? windowElement.document.documentElement : null;\n}\nfunction calculatePoints(element, resolver) {\n    const height = extractHeightForElement(resolver);\n    return resolver.isWindow\n        ? calculatePointsForWindow(height, element, resolver)\n        : calculatePointsForElement(height, element, resolver);\n}\nfunction calculatePointsForWindow(height, element, resolver) {\n    const { axis, container, isWindow } = resolver;\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    // scrolled until now / current y point\n    const scrolled = height +\n        getElementPageYOffset(getDocumentElement(isWindow, container), axis, isWindow);\n    // total height / most bottom y point\n    const nativeElementHeight = getElementHeight(element.nativeElement, isWindow, offsetHeightKey, clientHeightKey);\n    const totalToScroll = getElementOffsetTop(element.nativeElement, axis, isWindow) +\n        nativeElementHeight;\n    return { height, scrolled, totalToScroll, isWindow };\n}\nfunction calculatePointsForElement(height, element, resolver) {\n    const { axis, container } = resolver;\n    // perhaps use container.offsetTop instead of 'scrollTop'\n    const scrolled = container[axis.scrollTopKey()];\n    const totalToScroll = container[axis.scrollHeightKey()];\n    return { height, scrolled, totalToScroll, isWindow: false };\n}\nfunction extractHeightPropKeys(axis) {\n    return {\n        offsetHeightKey: axis.offsetHeightKey(),\n        clientHeightKey: axis.clientHeightKey(),\n    };\n}\nfunction extractHeightForElement({ container, isWindow, axis, }) {\n    const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n    return getElementHeight(container, isWindow, offsetHeightKey, clientHeightKey);\n}\nfunction getElementHeight(elem, isWindow, offsetHeightKey, clientHeightKey) {\n    if (isNaN(elem[offsetHeightKey])) {\n        const docElem = getDocumentElement(isWindow, elem);\n        return docElem ? docElem[clientHeightKey] : 0;\n    }\n    else {\n        return elem[offsetHeightKey];\n    }\n}\nfunction getElementOffsetTop(elem, axis, isWindow) {\n    const topKey = axis.topKey();\n    // elem = elem.nativeElement;\n    if (!elem.getBoundingClientRect) {\n        // || elem.css('none')) {\n        return;\n    }\n    return (elem.getBoundingClientRect()[topKey] +\n        getElementPageYOffset(elem, axis, isWindow));\n}\nfunction getElementPageYOffset(elem, axis, isWindow) {\n    const pageYOffset = axis.pageYOffsetKey();\n    const scrollTop = axis.scrollTopKey();\n    const offsetTop = axis.offsetTopKey();\n    if (isNaN(window.pageYOffset)) {\n        return getDocumentElement(isWindow, elem)[scrollTop];\n    }\n    else if (elem.ownerDocument) {\n        return elem.ownerDocument.defaultView[pageYOffset];\n    }\n    else {\n        return elem[offsetTop];\n    }\n}\n\nfunction shouldFireScrollEvent(container, distance = { down: 0, up: 0 }, scrollingDown) {\n    let remaining;\n    let containerBreakpoint;\n    if (container.totalToScroll <= 0) {\n        return false;\n    }\n    const scrolledUntilNow = container.isWindow\n        ? container.scrolled\n        : container.height + container.scrolled;\n    if (scrollingDown) {\n        remaining =\n            (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n        const distanceDown = (distance === null || distance === void 0 ? void 0 : distance.down) ? distance.down : 0;\n        containerBreakpoint = distanceDown / 10;\n    }\n    else {\n        const totalHiddenContentHeight = container.scrolled + (container.totalToScroll - scrolledUntilNow);\n        remaining = container.scrolled / totalHiddenContentHeight;\n        const distanceUp = (distance === null || distance === void 0 ? void 0 : distance.up) ? distance.up : 0;\n        containerBreakpoint = distanceUp / 10;\n    }\n    const shouldFireEvent = remaining <= containerBreakpoint;\n    return shouldFireEvent;\n}\nfunction isScrollingDownwards(lastScrollPosition, container) {\n    return lastScrollPosition < container.scrolled;\n}\nfunction getScrollStats(lastScrollPosition, container, distance) {\n    const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n    return {\n        fire: shouldFireScrollEvent(container, distance, scrollDown),\n        scrollDown,\n    };\n}\nfunction updateScrollPosition(position, scrollState) {\n    return (scrollState.lastScrollPosition = position);\n}\nfunction updateTotalToScroll(totalToScroll, scrollState) {\n    if (scrollState.lastTotalToScroll !== totalToScroll) {\n        scrollState.lastTotalToScroll = scrollState.totalToScroll;\n        scrollState.totalToScroll = totalToScroll;\n    }\n}\nfunction isSameTotalToScroll(scrollState) {\n    return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\nfunction updateTriggeredFlag(scroll, scrollState, triggered, isScrollingDown) {\n    if (isScrollingDown) {\n        scrollState.triggered.down = scroll;\n    }\n    else {\n        scrollState.triggered.up = scroll;\n    }\n}\nfunction isTriggeredScroll(totalToScroll, scrollState, isScrollingDown) {\n    return isScrollingDown\n        ? scrollState.triggered.down === totalToScroll\n        : scrollState.triggered.up === totalToScroll;\n}\nfunction updateScrollState(scrollState, scrolledUntilNow, totalToScroll) {\n    updateScrollPosition(scrolledUntilNow, scrollState);\n    updateTotalToScroll(totalToScroll, scrollState);\n    // const isSameTotal = isSameTotalToScroll(scrollState);\n    // if (!isSameTotal) {\n    //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n    // }\n}\n\nclass ScrollState {\n    constructor({ totalToScroll }) {\n        this.lastScrollPosition = 0;\n        this.lastTotalToScroll = 0;\n        this.totalToScroll = 0;\n        this.triggered = {\n            down: 0,\n            up: 0,\n        };\n        this.totalToScroll = totalToScroll;\n    }\n    updateScrollPosition(position) {\n        return (this.lastScrollPosition = position);\n    }\n    updateTotalToScroll(totalToScroll) {\n        if (this.lastTotalToScroll !== totalToScroll) {\n            this.lastTotalToScroll = this.totalToScroll;\n            this.totalToScroll = totalToScroll;\n        }\n    }\n    updateScroll(scrolledUntilNow, totalToScroll) {\n        this.updateScrollPosition(scrolledUntilNow);\n        this.updateTotalToScroll(totalToScroll);\n    }\n    updateTriggeredFlag(scroll, isScrollingDown) {\n        if (isScrollingDown) {\n            this.triggered.down = scroll;\n        }\n        else {\n            this.triggered.up = scroll;\n        }\n    }\n    isTriggeredScroll(totalToScroll, isScrollingDown) {\n        return isScrollingDown\n            ? this.triggered.down === totalToScroll\n            : this.triggered.up === totalToScroll;\n    }\n}\n\nfunction createScroller(config) {\n    const { scrollContainer, scrollWindow, element, fromRoot } = config;\n    const resolver = createResolver({\n        axis: new AxisResolver(!config.horizontal),\n        windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot),\n    });\n    const scrollState = new ScrollState({\n        totalToScroll: calculatePoints(element, resolver),\n    });\n    const options = {\n        container: resolver.container,\n        throttle: config.throttle,\n    };\n    const distance = {\n        up: config.upDistance,\n        down: config.downDistance,\n    };\n    return attachScrollEvent(options).pipe(mergeMap(() => of(calculatePoints(element, resolver))), map((positionStats) => toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance)), tap(({ stats }) => scrollState.updateScroll(stats.scrolled, stats.totalToScroll)), filter(({ fire, scrollDown, stats: { totalToScroll } }) => shouldTriggerEvents(config.alwaysCallback, fire, scrollState.isTriggeredScroll(totalToScroll, scrollDown))), tap(({ scrollDown, stats: { totalToScroll } }) => {\n        scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    }), map(toInfiniteScrollAction));\n}\nfunction attachScrollEvent(options) {\n    let obs = fromEvent(options.container, 'scroll');\n    // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n    // Let's avoid calling the function unless needed.\n    // Replacing with throttleTime seems to solve the problem\n    // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n    if (options.throttle) {\n        obs = obs.pipe(throttleTime(options.throttle, undefined, {\n            leading: true,\n            trailing: true,\n        }));\n    }\n    return obs;\n}\nfunction toInfiniteScrollParams(lastScrollPosition, stats, distance) {\n    const { scrollDown, fire } = getScrollStats(lastScrollPosition, stats, distance);\n    return {\n        scrollDown,\n        fire,\n        stats,\n    };\n}\nconst InfiniteScrollActions = {\n    DOWN: '[NGX_ISE] DOWN',\n    UP: '[NGX_ISE] UP',\n};\nfunction toInfiniteScrollAction(response) {\n    const { scrollDown, stats: { scrolled: currentScrollPosition }, } = response;\n    return {\n        type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n        payload: {\n            currentScrollPosition,\n        },\n    };\n}\n\nclass InfiniteScrollDirective {\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.scrolled = new EventEmitter();\n        this.scrolledUp = new EventEmitter();\n        this.infiniteScrollDistance = 2;\n        this.infiniteScrollUpDistance = 1.5;\n        this.infiniteScrollThrottle = 150;\n        this.infiniteScrollDisabled = false;\n        this.infiniteScrollContainer = null;\n        this.scrollWindow = true;\n        this.immediateCheck = false;\n        this.horizontal = false;\n        this.alwaysCallback = false;\n        this.fromRoot = false;\n    }\n    ngAfterViewInit() {\n        if (!this.infiniteScrollDisabled) {\n            this.setup();\n        }\n    }\n    ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance, }) {\n        const containerChanged = inputPropChanged(infiniteScrollContainer);\n        const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n        const distanceChanged = inputPropChanged(infiniteScrollDistance);\n        const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n            (disabledChanged && !infiniteScrollDisabled.currentValue) ||\n            distanceChanged;\n        if (containerChanged || disabledChanged || distanceChanged) {\n            this.destroyScroller();\n            if (shouldSetup) {\n                this.setup();\n            }\n        }\n    }\n    setup() {\n        if (hasWindowDefined()) {\n            this.zone.runOutsideAngular(() => {\n                this.disposeScroller = createScroller({\n                    fromRoot: this.fromRoot,\n                    alwaysCallback: this.alwaysCallback,\n                    disable: this.infiniteScrollDisabled,\n                    downDistance: this.infiniteScrollDistance,\n                    element: this.element,\n                    horizontal: this.horizontal,\n                    scrollContainer: this.infiniteScrollContainer,\n                    scrollWindow: this.scrollWindow,\n                    throttle: this.infiniteScrollThrottle,\n                    upDistance: this.infiniteScrollUpDistance,\n                }).subscribe((payload) => this.zone.run(() => this.handleOnScroll(payload)));\n            });\n        }\n    }\n    handleOnScroll({ type, payload }) {\n        switch (type) {\n            case InfiniteScrollActions.DOWN:\n                return this.scrolled.emit(payload);\n            case InfiniteScrollActions.UP:\n                return this.scrolledUp.emit(payload);\n            default:\n                return;\n        }\n    }\n    ngOnDestroy() {\n        this.destroyScroller();\n    }\n    destroyScroller() {\n        if (this.disposeScroller) {\n            this.disposeScroller.unsubscribe();\n        }\n    }\n}\nInfiniteScrollDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.3\", ngImport: i0, type: InfiniteScrollDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });\nInfiniteScrollDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.1.3\", type: InfiniteScrollDirective, selector: \"[infiniteScroll], [infinite-scroll], [data-infinite-scroll]\", inputs: { infiniteScrollDistance: \"infiniteScrollDistance\", infiniteScrollUpDistance: \"infiniteScrollUpDistance\", infiniteScrollThrottle: \"infiniteScrollThrottle\", infiniteScrollDisabled: \"infiniteScrollDisabled\", infiniteScrollContainer: \"infiniteScrollContainer\", scrollWindow: \"scrollWindow\", immediateCheck: \"immediateCheck\", horizontal: \"horizontal\", alwaysCallback: \"alwaysCallback\", fromRoot: \"fromRoot\" }, outputs: { scrolled: \"scrolled\", scrolledUp: \"scrolledUp\" }, usesOnChanges: true, ngImport: i0 });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.3\", ngImport: i0, type: InfiniteScrollDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]',\n                }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { scrolled: [{\n                type: Output\n            }], scrolledUp: [{\n                type: Output\n            }], infiniteScrollDistance: [{\n                type: Input\n            }], infiniteScrollUpDistance: [{\n                type: Input\n            }], infiniteScrollThrottle: [{\n                type: Input\n            }], infiniteScrollDisabled: [{\n                type: Input\n            }], infiniteScrollContainer: [{\n                type: Input\n            }], scrollWindow: [{\n                type: Input\n            }], immediateCheck: [{\n                type: Input\n            }], horizontal: [{\n                type: Input\n            }], alwaysCallback: [{\n                type: Input\n            }], fromRoot: [{\n                type: Input\n            }] } });\n\nclass InfiniteScrollModule {\n}\nInfiniteScrollModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.3\", ngImport: i0, type: InfiniteScrollModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nInfiniteScrollModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.1.3\", ngImport: i0, type: InfiniteScrollModule, declarations: [InfiniteScrollDirective], exports: [InfiniteScrollDirective] });\nInfiniteScrollModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.1.3\", ngImport: i0, type: InfiniteScrollModule, providers: [], imports: [[]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.3\", ngImport: i0, type: InfiniteScrollModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [InfiniteScrollDirective],\n                    exports: [InfiniteScrollDirective],\n                    imports: [],\n                    providers: [],\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-infinite-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InfiniteScrollDirective, InfiniteScrollModule, NgxInfiniteScrollService };\n"]},"metadata":{},"sourceType":"module"}