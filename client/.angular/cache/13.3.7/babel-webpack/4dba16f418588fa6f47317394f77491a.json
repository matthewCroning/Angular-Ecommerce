{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Matth\\\\workspace\\\\angular-ecommerce\\\\client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n} // The input can also be a promise, so we await it\n\n\nconst testElement = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (element, tester) {\n    return tester(yield element);\n  });\n\n  return function testElement(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // The input can also be a promise, so we `Promise.all()` them both\n\n\nconst finder = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (element) {\n    const values = yield Promise.all(element);\n\n    if (values[1] === true) {\n      throw new EndError(values[0]);\n    }\n\n    return false;\n  });\n\n  return function finder(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst pLocate = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (iterable, tester, options) {\n    options = {\n      concurrency: Infinity,\n      preserveOrder: true,\n      ...options\n    };\n    const limit = pLimit(options.concurrency); // Start all the promises concurrently with optional limit\n\n    const items = [...iterable].map(element => [element, limit(testElement, element, tester)]); // Check the promises either serially or concurrently\n\n    const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n    try {\n      yield Promise.all(items.map(element => checkLimit(finder, element)));\n    } catch (error) {\n      if (error instanceof EndError) {\n        return error.value;\n      }\n\n      throw error;\n    }\n  });\n\n  return function pLocate(_x4, _x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nmodule.exports = pLocate; // TODO: Remove this for the next major release\n\nmodule.exports.default = pLocate;","map":{"version":3,"sources":["C:/Users/Matth/workspace/node_modules/p-locate/index.js"],"names":["pLimit","require","EndError","Error","constructor","value","testElement","element","tester","finder","values","Promise","all","pLocate","iterable","options","concurrency","Infinity","preserveOrder","limit","items","map","checkLimit","error","module","exports","default"],"mappings":"AAAA;;;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AAEA,MAAMC,QAAN,SAAuBC,KAAvB,CAA6B;AAC5BC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AAClB;AACA,SAAKA,KAAL,GAAaA,KAAb;AACA;;AAJ2B,C,CAO7B;;;AACA,MAAMC,WAAW;AAAA,+BAAG,WAAOC,OAAP,EAAgBC,MAAhB;AAAA,WAA2BA,MAAM,OAAOD,OAAP,CAAjC;AAAA,GAAH;;AAAA,kBAAXD,WAAW;AAAA;AAAA;AAAA,GAAjB,C,CAEA;;;AACA,MAAMG,MAAM;AAAA,gCAAG,WAAMF,OAAN,EAAiB;AAC/B,UAAMG,MAAM,SAASC,OAAO,CAACC,GAAR,CAAYL,OAAZ,CAArB;;AACA,QAAIG,MAAM,CAAC,CAAD,CAAN,KAAc,IAAlB,EAAwB;AACvB,YAAM,IAAIR,QAAJ,CAAaQ,MAAM,CAAC,CAAD,CAAnB,CAAN;AACA;;AAED,WAAO,KAAP;AACA,GAPW;;AAAA,kBAAND,MAAM;AAAA;AAAA;AAAA,GAAZ;;AASA,MAAMI,OAAO;AAAA,gCAAG,WAAOC,QAAP,EAAiBN,MAAjB,EAAyBO,OAAzB,EAAqC;AACpDA,IAAAA,OAAO,GAAG;AACTC,MAAAA,WAAW,EAAEC,QADJ;AAETC,MAAAA,aAAa,EAAE,IAFN;AAGT,SAAGH;AAHM,KAAV;AAMA,UAAMI,KAAK,GAAGnB,MAAM,CAACe,OAAO,CAACC,WAAT,CAApB,CAPoD,CASpD;;AACA,UAAMI,KAAK,GAAG,CAAC,GAAGN,QAAJ,EAAcO,GAAd,CAAkBd,OAAO,IAAI,CAACA,OAAD,EAAUY,KAAK,CAACb,WAAD,EAAcC,OAAd,EAAuBC,MAAvB,CAAf,CAA7B,CAAd,CAVoD,CAYpD;;AACA,UAAMc,UAAU,GAAGtB,MAAM,CAACe,OAAO,CAACG,aAAR,GAAwB,CAAxB,GAA4BD,QAA7B,CAAzB;;AAEA,QAAI;AACH,YAAMN,OAAO,CAACC,GAAR,CAAYQ,KAAK,CAACC,GAAN,CAAUd,OAAO,IAAIe,UAAU,CAACb,MAAD,EAASF,OAAT,CAA/B,CAAZ,CAAN;AACA,KAFD,CAEE,OAAOgB,KAAP,EAAc;AACf,UAAIA,KAAK,YAAYrB,QAArB,EAA+B;AAC9B,eAAOqB,KAAK,CAAClB,KAAb;AACA;;AAED,YAAMkB,KAAN;AACA;AACD,GAxBY;;AAAA,kBAAPV,OAAO;AAAA;AAAA;AAAA,GAAb;;AA0BAW,MAAM,CAACC,OAAP,GAAiBZ,OAAjB,C,CACA;;AACAW,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyBb,OAAzB","sourcesContent":["'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we await it\nconst testElement = async (element, tester) => tester(await element);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = async element => {\n\tconst values = await Promise.all(element);\n\tif (values[1] === true) {\n\t\tthrow new EndError(values[0]);\n\t}\n\n\treturn false;\n};\n\nconst pLocate = async (iterable, tester, options) => {\n\toptions = {\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true,\n\t\t...options\n\t};\n\n\tconst limit = pLimit(options.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(element => [element, limit(testElement, element, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n\ttry {\n\t\tawait Promise.all(items.map(element => checkLimit(finder, element)));\n\t} catch (error) {\n\t\tif (error instanceof EndError) {\n\t\t\treturn error.value;\n\t\t}\n\n\t\tthrow error;\n\t}\n};\n\nmodule.exports = pLocate;\n// TODO: Remove this for the next major release\nmodule.exports.default = pLocate;\n"]},"metadata":{},"sourceType":"script"}