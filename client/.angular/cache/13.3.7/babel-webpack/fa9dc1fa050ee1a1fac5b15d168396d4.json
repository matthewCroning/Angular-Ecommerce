{"ast":null,"code":"var _asyncToGenerator = require(\"C:\\\\Users\\\\Matth\\\\workspace\\\\angular-ecommerce\\\\client\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nconst debug = require('debug')('extract-zip'); // eslint-disable-next-line node/no-unsupported-features/node-builtins\n\n\nconst {\n  createWriteStream,\n  promises: fs\n} = require('fs');\n\nconst getStream = require('get-stream');\n\nconst path = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst stream = require('stream');\n\nconst yauzl = require('yauzl');\n\nconst openZip = promisify(yauzl.open);\nconst pipeline = promisify(stream.pipeline);\n\nclass Extractor {\n  constructor(zipPath, opts) {\n    this.zipPath = zipPath;\n    this.opts = opts;\n  }\n\n  extract() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      debug('opening', _this.zipPath, 'with opts', _this.opts);\n      _this.zipfile = yield openZip(_this.zipPath, {\n        lazyEntries: true\n      });\n      _this.canceled = false;\n      return new Promise((resolve, reject) => {\n        _this.zipfile.on('error', err => {\n          _this.canceled = true;\n          reject(err);\n        });\n\n        _this.zipfile.readEntry();\n\n        _this.zipfile.on('close', () => {\n          if (!_this.canceled) {\n            debug('zip extraction complete');\n            resolve();\n          }\n        });\n\n        _this.zipfile.on('entry', /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (entry) {\n            /* istanbul ignore if */\n            if (_this.canceled) {\n              debug('skipping entry', entry.fileName, {\n                cancelled: _this.canceled\n              });\n              return;\n            }\n\n            debug('zipfile entry', entry.fileName);\n\n            if (entry.fileName.startsWith('__MACOSX/')) {\n              _this.zipfile.readEntry();\n\n              return;\n            }\n\n            const destDir = path.dirname(path.join(_this.opts.dir, entry.fileName));\n\n            try {\n              yield fs.mkdir(destDir, {\n                recursive: true\n              });\n              const canonicalDestDir = yield fs.realpath(destDir);\n              const relativeDestDir = path.relative(_this.opts.dir, canonicalDestDir);\n\n              if (relativeDestDir.split(path.sep).includes('..')) {\n                throw new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${entry.fileName}`);\n              }\n\n              yield _this.extractEntry(entry);\n              debug('finished processing', entry.fileName);\n\n              _this.zipfile.readEntry();\n            } catch (err) {\n              _this.canceled = true;\n\n              _this.zipfile.close();\n\n              reject(err);\n            }\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      });\n    })();\n  }\n\n  extractEntry(entry) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      /* istanbul ignore if */\n      if (_this2.canceled) {\n        debug('skipping entry extraction', entry.fileName, {\n          cancelled: _this2.canceled\n        });\n        return;\n      }\n\n      if (_this2.opts.onEntry) {\n        _this2.opts.onEntry(entry, _this2.zipfile);\n      }\n\n      const dest = path.join(_this2.opts.dir, entry.fileName); // convert external file attr int into a fs stat mode int\n\n      const mode = entry.externalFileAttributes >> 16 & 0xFFFF; // check if it's a symlink or dir (using stat mode constants)\n\n      const IFMT = 61440;\n      const IFDIR = 16384;\n      const IFLNK = 40960;\n      const symlink = (mode & IFMT) === IFLNK;\n      let isDir = (mode & IFMT) === IFDIR; // Failsafe, borrowed from jsZip\n\n      if (!isDir && entry.fileName.endsWith('/')) {\n        isDir = true;\n      } // check for windows weird way of specifying a directory\n      // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n\n\n      const madeBy = entry.versionMadeBy >> 8;\n      if (!isDir) isDir = madeBy === 0 && entry.externalFileAttributes === 16;\n      debug('extracting entry', {\n        filename: entry.fileName,\n        isDir: isDir,\n        isSymlink: symlink\n      });\n      const procMode = _this2.getExtractedMode(mode, isDir) & 0o777; // always ensure folders are created\n\n      const destDir = isDir ? dest : path.dirname(dest);\n      const mkdirOptions = {\n        recursive: true\n      };\n\n      if (isDir) {\n        mkdirOptions.mode = procMode;\n      }\n\n      debug('mkdir', {\n        dir: destDir,\n        ...mkdirOptions\n      });\n      yield fs.mkdir(destDir, mkdirOptions);\n      if (isDir) return;\n      debug('opening read stream', dest);\n      const readStream = yield promisify(_this2.zipfile.openReadStream.bind(_this2.zipfile))(entry);\n\n      if (symlink) {\n        const link = yield getStream(readStream);\n        debug('creating symlink', link, dest);\n        yield fs.symlink(link, dest);\n      } else {\n        yield pipeline(readStream, createWriteStream(dest, {\n          mode: procMode\n        }));\n      }\n    })();\n  }\n\n  getExtractedMode(entryMode, isDir) {\n    let mode = entryMode; // Set defaults, if necessary\n\n    if (mode === 0) {\n      if (isDir) {\n        if (this.opts.defaultDirMode) {\n          mode = parseInt(this.opts.defaultDirMode, 10);\n        }\n\n        if (!mode) {\n          mode = 0o755;\n        }\n      } else {\n        if (this.opts.defaultFileMode) {\n          mode = parseInt(this.opts.defaultFileMode, 10);\n        }\n\n        if (!mode) {\n          mode = 0o644;\n        }\n      }\n    }\n\n    return mode;\n  }\n\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (zipPath, opts) {\n    debug('creating target directory', opts.dir);\n\n    if (!path.isAbsolute(opts.dir)) {\n      throw new Error('Target directory is expected to be absolute');\n    }\n\n    yield fs.mkdir(opts.dir, {\n      recursive: true\n    });\n    opts.dir = yield fs.realpath(opts.dir);\n    return new Extractor(zipPath, opts).extract();\n  });\n\n  return function (_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["C:/Users/Matth/workspace/node_modules/extract-zip/index.js"],"names":["debug","require","createWriteStream","promises","fs","getStream","path","promisify","stream","yauzl","openZip","open","pipeline","Extractor","constructor","zipPath","opts","extract","zipfile","lazyEntries","canceled","Promise","resolve","reject","on","err","readEntry","entry","fileName","cancelled","startsWith","destDir","dirname","join","dir","mkdir","recursive","canonicalDestDir","realpath","relativeDestDir","relative","split","sep","includes","Error","extractEntry","close","onEntry","dest","mode","externalFileAttributes","IFMT","IFDIR","IFLNK","symlink","isDir","endsWith","madeBy","versionMadeBy","filename","isSymlink","procMode","getExtractedMode","mkdirOptions","readStream","openReadStream","bind","link","entryMode","defaultDirMode","parseInt","defaultFileMode","module","exports","isAbsolute"],"mappings":"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","sourcesContent":["const debug = require('debug')('extract-zip')\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst { createWriteStream, promises: fs } = require('fs')\nconst getStream = require('get-stream')\nconst path = require('path')\nconst { promisify } = require('util')\nconst stream = require('stream')\nconst yauzl = require('yauzl')\n\nconst openZip = promisify(yauzl.open)\nconst pipeline = promisify(stream.pipeline)\n\nclass Extractor {\n  constructor (zipPath, opts) {\n    this.zipPath = zipPath\n    this.opts = opts\n  }\n\n  async extract () {\n    debug('opening', this.zipPath, 'with opts', this.opts)\n\n    this.zipfile = await openZip(this.zipPath, { lazyEntries: true })\n    this.canceled = false\n\n    return new Promise((resolve, reject) => {\n      this.zipfile.on('error', err => {\n        this.canceled = true\n        reject(err)\n      })\n      this.zipfile.readEntry()\n\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          debug('zip extraction complete')\n          resolve()\n        }\n      })\n\n      this.zipfile.on('entry', async entry => {\n        /* istanbul ignore if */\n        if (this.canceled) {\n          debug('skipping entry', entry.fileName, { cancelled: this.canceled })\n          return\n        }\n\n        debug('zipfile entry', entry.fileName)\n\n        if (entry.fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry()\n          return\n        }\n\n        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName))\n\n        try {\n          await fs.mkdir(destDir, { recursive: true })\n\n          const canonicalDestDir = await fs.realpath(destDir)\n          const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir)\n\n          if (relativeDestDir.split(path.sep).includes('..')) {\n            throw new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${entry.fileName}`)\n          }\n\n          await this.extractEntry(entry)\n          debug('finished processing', entry.fileName)\n          this.zipfile.readEntry()\n        } catch (err) {\n          this.canceled = true\n          this.zipfile.close()\n          reject(err)\n        }\n      })\n    })\n  }\n\n  async extractEntry (entry) {\n    /* istanbul ignore if */\n    if (this.canceled) {\n      debug('skipping entry extraction', entry.fileName, { cancelled: this.canceled })\n      return\n    }\n\n    if (this.opts.onEntry) {\n      this.opts.onEntry(entry, this.zipfile)\n    }\n\n    const dest = path.join(this.opts.dir, entry.fileName)\n\n    // convert external file attr int into a fs stat mode int\n    const mode = (entry.externalFileAttributes >> 16) & 0xFFFF\n    // check if it's a symlink or dir (using stat mode constants)\n    const IFMT = 61440\n    const IFDIR = 16384\n    const IFLNK = 40960\n    const symlink = (mode & IFMT) === IFLNK\n    let isDir = (mode & IFMT) === IFDIR\n\n    // Failsafe, borrowed from jsZip\n    if (!isDir && entry.fileName.endsWith('/')) {\n      isDir = true\n    }\n\n    // check for windows weird way of specifying a directory\n    // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n    const madeBy = entry.versionMadeBy >> 8\n    if (!isDir) isDir = (madeBy === 0 && entry.externalFileAttributes === 16)\n\n    debug('extracting entry', { filename: entry.fileName, isDir: isDir, isSymlink: symlink })\n\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777\n\n    // always ensure folders are created\n    const destDir = isDir ? dest : path.dirname(dest)\n\n    const mkdirOptions = { recursive: true }\n    if (isDir) {\n      mkdirOptions.mode = procMode\n    }\n    debug('mkdir', { dir: destDir, ...mkdirOptions })\n    await fs.mkdir(destDir, mkdirOptions)\n    if (isDir) return\n\n    debug('opening read stream', dest)\n    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry)\n\n    if (symlink) {\n      const link = await getStream(readStream)\n      debug('creating symlink', link, dest)\n      await fs.symlink(link, dest)\n    } else {\n      await pipeline(readStream, createWriteStream(dest, { mode: procMode }))\n    }\n  }\n\n  getExtractedMode (entryMode, isDir) {\n    let mode = entryMode\n    // Set defaults, if necessary\n    if (mode === 0) {\n      if (isDir) {\n        if (this.opts.defaultDirMode) {\n          mode = parseInt(this.opts.defaultDirMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o755\n        }\n      } else {\n        if (this.opts.defaultFileMode) {\n          mode = parseInt(this.opts.defaultFileMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o644\n        }\n      }\n    }\n\n    return mode\n  }\n}\n\nmodule.exports = async function (zipPath, opts) {\n  debug('creating target directory', opts.dir)\n\n  if (!path.isAbsolute(opts.dir)) {\n    throw new Error('Target directory is expected to be absolute')\n  }\n\n  await fs.mkdir(opts.dir, { recursive: true })\n  opts.dir = await fs.realpath(opts.dir)\n  return new Extractor(zipPath, opts).extract()\n}\n"]},"metadata":{},"sourceType":"script"}